* Setting for current buffer
# -*- mode: org; -*-
** solorized dark
##+BEGIN_SRC html
#+INFOJS_OPT: view:t toc:t ltoc:t mouse:underline buttons:0 path:../20171201201933/elements/org-info.min.js
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../20171201201933/elements/solarized-dark.min.css" />
##+END_SRC
 
#+TITLE: org-translate
#+AUTHOR: Entropy
** read the org
#+BEGIN_SRC 
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../20171116130000/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../20171116130000/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="../20171116130000/jquery.min.js"></script>
#+HTML_HEAD: <script src="../20171116130000/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="../20171116130000/styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="../20171116130000/styles/readtheorg/js/readtheorg.js"></script>
#+END_SRC

* Publish
** Chapter 1: Introduction
*** 概览 Summary 
    org是一种整理笔记，维护任务列表以及项目计划伴随着快速和有效的纯文本系统的模式。它也是
    一种伴随着可读性编程和可再生研究得特殊支持的创作系统。
    
    Org is a mode for keeping notes, maintaining TODO lists, and project planning with a
    fast and effective plain-text system. It also is an authoring system with unique
    support for literate programming and reproducible research.
    
    Org模式被实现在大纲模式之上，大纲模式使得它能够让大型文件保持良好的结构化展示。可显示
    的循环操作和结构化编辑帮助人们以树状方式工作。表格可以很简单的利用内建的表格编辑器创
    建。纯文本的链接样式的链接链接到网站，email，用户网络信息，BBDB和热门和项目相关的文件。
    #+BEGIN_EXAMPLE
    BBDB是一个通讯录管理软件。
    #+END_EXAMPLE

    Org is implemented on top of Outline mode, which makes it possible to keep the
    content of large files well structured. Visibility cycling and structure editing
    help to work with the tree. Tables are easily created with a built-in table
    editor. Plain text URL-like links connect to websites, emails, Usenet messages, BBDB
    entries, and any files related to the projects.

    Org开发由组织的任务，这些任务围绕这笔记文件，这些笔记文件包含着列表或者一些信息，这些
    信息关于以纯文本方式存储的项目。项目计划和任务管理利用元数据,这些元数据是大纲节点的一
    部分。基于这种数据，独特的条目可以在查询搜索中提取，并且这种数据创造出动态的日程显示，
    日程管理 =agenda views=也是综合来Emacs的日历和日记模块。org制造可以用来实现许多不同的
    项目计划方案，例如David Allen的GTD系统。
    #+BEGIN_QUOTE
    [[https://www.youtube.com/watch?v=Qo7vUdKTlhk][David Allen GTD system]]
    #+END_QUOTE

    Org develops organizational tasks around notes files that contain lists or
    information about projects as plain text. Project planning and task management makes
    use of metadata which is part of an outline node. Based on this data, specific
    entries can be extracted in queries and create dynamic agenda views that also
    integrate the Emacs calendar and diary.  Org can be used to implement many different
    project planning schemes, such as David Allen’s GTD system.

    org文件可以以一种单读的源代码形式的创作系统的凡是服务，它能够输出许多不同的格式，例如：
    =HTML= ， =latex= , 开源文档和 =Markdown= 文件。新的格式可以从现存的格式导出，或者从
    编程语言中定义。

    Org files can serve as a single source authoring system with export to many
    different formats such as HTML, L A TEX, Open Document, and Markdown. New export
    backends can be derived from existing ones, or defined from scratch.

    Org文件可以包括源代码区块，这使得Org独特的支持以代码事例的方式创作技术性文章。Org源代
    码区块是全功能的；它们可以在适当的地方被求值，结果能被在文件中捕获。这使得它能够创建
    一个单独的伴随着可重现的研究文稿材料的文件。

    Org files can include source code blocks, which makes Org uniquely suited for
    authoring technical documents with code examples. Org source code blocks are fully
    functional; they can be evaluated in place and their results can be captured in the
    file. This makes it possible to create a single file reproducible research
    compendium.

    Org使得简单的事情保持简单的特性。首次上手它因该感觉像是很直白的，且大纲是很容易使用的。
    复杂的特性添加并不是强制的，除非许多功能在需要被使用的时候才被添加。Org是一个工具箱。
    许多用户实际上之用了org能力的很小一部分功能，而且知道在它们需要的时候，有根多的功能。

    Org keeps simple things simple. When first fired up, it should feel like a
    straightforward, easy to use outliner. Complexity is not imposed, but a large amount
    of functionality is available when needed. Org is a toolbox. Many users actually run
    only a (very personal) fraction of Org’s capabilities, and know that there is more
    whenever they need it.

    所有的这些都是从绝对纯文本的文件中获取的，这是最可编写和不会过时的文件格式。Org在
    Emacs中运行。Emacs是拥有最广扩可移植性质的程序之一，所以org模式在任何主流平台上都是可
    用的。

    All of this is achieved with strictly plain text files, the most portable and
    future-proof file format. Org runs in Emacs. Emacs is one of the most widely ported
    programs, so that Org mode is available on every major platform.

    这里有一个关于Org的网站，它提供了org版本的最新链接，同样拥有着更多的扩展信息，FAQ，以
    及使用指南等链接。这一页存放在http://orgmode.org.

    There is a website for Org which provides links to the newest version of Org, as
    well as additional information, frequently asked questions (FAQ), links to
    tutorials, etc. This page is located at http://orgmode.org.

    次手册的早期版本（7.3）存放在[[http://www.network-theory.co.uk/org/manual/][paperback book from Network Theory Ltd.]]

    An earlier version (7.3) of this manual is available as a paperback book from
    Network Theory Ltd.
*** 安装 Installation




* Druft paper
* Spacemacs Rocks 第二季
*GitHub* [[https://github.com/emacs-china/Spacemacs-rocks][Spacemacs Rocks]] *作者* [[https://github.com/zilongshanren/][zilongshanren]] *编者* [[https://github.com/li-xinyang][li-xinyang]], [[https://github.com/lsytj0413][lsytj0413]]

在这一季中我们计划用 21 天学习 Emacs 以及 Spacemacs 的使用。从基础安装开始到可以
运用到工作生产环节中。为了确保学习质量，请务必完成和理解计划中的每一项学习任务。

** 第一天：准备开始

 视频地址如下

 -  [[http://v.youku.com/v_show/id_XMTUwNjU0MjE0OA==.html][优酷视频]]
 -  [[http://pan.baidu.com/s/1gep9DQV][百度网盘]]
 -  [[https://youtu.be/QKhS9EX9qd8][YouTube]]

 *说在最前面*

 如果你第一次听说 Emacs 你可以在[[http://emacs.sexy/][性感的 Emacs（Emacs is Sexy）]]一文中找到使用它的理
 由！我相信你一定会被它的强大所吸引。

 如果你还没有安装 Emacs 可以在 [[http://emacsformacosx.com/builds][Mac OS X 安装链接]]以及 [[http://emacsbinw64.sourceforge.net/][Window 安装链接]]找到它。本文
 我们使用的为 Emacs 25.0.x Pretest 版本，一些配置在 Emacs 24 中可能并不适用。

 在开始本教程之前请务必先完成 Emacs 提供的官方教程（完成时间大约 30 分钟），它可
 以通过使用 =C-h t= （同时按住 Ctrl 与 h 键，接着按 t 键 =t= 在这里代表 tutorial）
 在 Emacs 中直接将其打开。

 Emacs Lisp 是 Emacs 所用的编程语言，你可以在阅读[[https://learnxinyminutes.com/docs/elisp/][这篇教程（Learn X in Y Minutes）]]
 后很快地了解它的基础用法。

*** 基础操作

 因为 Control 键在 Emacs 中极为常用，所以为了更方便地使用 Emacs 的键位修改，需要
 对其做出修改。建议将大写锁定键（Caps Lock）替换为 Control 键。这里是一个可以参考
 的把大写锁定键替换为 Control 键的教程：[[https://www.emacswiki.org/emacs/MovingTheCtrlKey][移动 Control 键 (Moving The Ctrl Key)。]]如
 果这个的教程不适用于你的操作系统，请自行搜索其它的修改方式。

 常见符号所代表的意义如下

 -  M(eta)，在 Mac 下为 Option 键
 -  s(uper)，在 Mac 环境下为左 Command 键
 -  S(Shift)
 -  C(trl)

 光标的移动是编辑器中最常用的操作所以必须熟知。

 -  =C-f= 为前移一个字符， =f= 代表 forward。
 -  =C-b= 为后移一个字符， =b= 代表 backward。
 -  =C-p= 为上移至前一行， =p= 代表 previous。
 -  =C-n= 为上移至下一行， =n= 代表 next。
 -  =C-a= 为移至行首， =a= 代表 ahead。
 -  =C-e= 为移至行尾， =e= 代表 end。

 常用的文件操作快捷键组合也必须熟记。

 -  =C-x C-f= 为打开目标文件， =f= 代表 find/file
 -  =C-x C-s= 为保存当前缓冲区（Buffer）， =s= 代表 save

 =C-x= 是 Emacs 的快捷键中常用的前缀命令。这些前缀命令常常代表了一系列有关联的指
 令，十分重要，请特别牢记。其它常见的还有 =C-c=, =C-h= 。打断组合键为 =C-g= ，它
 用于终端取消之前的指令。快捷键就是用预先绑定好的方式告诉 Emacs 去执行指定的命令。
 （之后会介绍到更多有关绑定的内容）

*** 内置功能

 Emacs 功能强大，但是部分功能默认情况下并未开启。下面就有几个例子，

 编辑器内显示行号可使用 =M-x linum-mode= 来开启。

 *获取帮助*

 Emacs 是一个富文档编辑器（Self document, extensible editor）而下面的三种方法在学
 习 Emacs 的过程中也非常重要。他们分别是，

 -  =C-h k= 寻找快捷键的帮助信息
 -  =C-h v= 寻找变量的帮助信息
 -  =C-h f= 寻找函数的帮助信息

*** 学习基础 Elisp

 请务必完成[[https://learnxinyminutes.com/docs/elisp/][这篇教程（Learn X in Y Minutes）]]来了解 Elisp 的使用（阅读时间大约 15
 分钟），你也可以在[[https://learnxinyminutes.com/docs/zh-cn/elisp-cn/][这里]]找到它的中文版。Emacs Lisp 为一个函数式的语言，所以它全部
 功能都是由函数来实现的。

 下面为一些简单的例子

 #+BEGIN_SRC emacs-lisp
     ;; 2 + 2
     (+ 2 2)

     ;; 2 + 3 * 4
     (+ 2 (* 3 4))

     ;; 定义变量
     (setq name "username")
     (message name) ; -> "username"

     ;; 定义函数
     (defun func ()
       (message "Hello, %s" name))

     ;; 执行函数
     (func) ; -> Hello, username

     ;; 设置快捷键
     (global-set-key (kbd "<f1>") 'func)

     ;; 使函数可直接被调用可添加 (interactive)
     (defun func ()
       (interactive)
       (message "Hello, %s" name))
 #+END_SRC

**** 开始 Hacking！

 Emacs 的配置文件默认保存在 =~/.emacs.d/init.el= 文件中。（如果其不存在可自行创建，
 配置文件也可保存在 =~/.emacs= 文件中，他们之间的区别我们会在后面做讨论）

 **注意：** 如果希望把配置放在 =~/.emacs.d/init.el= 文件中，那么需要手工删除
 =~/.emacs= 文件。

 在开始配置之前让我们先来区别 Emacs 中 Major Mode 与 Minor Mode 的区别。Major
 Mode 通常是定义对于一种文件类型编辑的核心规则，例如语法高亮、缩进、快捷键绑定等。
 而 Minor Mode 是除去 Major Mode 所提供的核心功能以外的额外编辑功能（辅助功能）。
 例如在下面的配置文件中 =tool-bar-mode= 与 =linum-mode= 等均为 Minor Mode*。

 简单来说就是，一种文件类型同时只能存在一种 Major Mode 但是它可以同时激活一种或多
 种 Minor Mode。如果你希望知道当前的模式信息，可以使用 =C-h m= 来显示当前所有开启
 的全部 Minor Mode 的信息。

 *简单的编辑器自定义*

 下面是一些简单的编辑器配置信息，你需要做的就是将其写入你的配置文件中
 （ =~/.emacs.d/init.el= ）即可。

 #+BEGIN_SRC emacs-lisp
     ;; 关闭工具栏，tool-bar-mode 即为一个 Minor Mode
     (tool-bar-mode -1)

     ;; 关闭文件滑动控件
     (scroll-bar-mode -1)

     ;; 显示行号
     (global-linum-mode 1)

     ;; 更改光标的样式（不能生效，解决方案见第二集）
     (setq cursor-type 'bar)

     ;; 关闭启动帮助画面
     (setq inhibit-splash-screen 1)

     ;; 关闭缩进 (第二天中被去除)
     ;; (electric-indent-mode -1)

     ;; 更改显示字体大小 16pt
     ;; http://stackoverflow.com/questions/294664/how-to-set-the-font-size-in-emacs
     (set-face-attribute 'default nil :height 160)

     ;; 快速打开配置文件
     (defun open-init-file()
       (interactive)
       (find-file "~/.emacs.d/init.el"))

     ;; 这一行代码，将函数 open-init-file 绑定到 <f2> 键上
     (global-set-key (kbd "<f2>") 'open-init-file)
 #+END_SRC

 在每次编辑配置文件后，刚刚做的修改并不会立刻生效。这时你需要重启编辑器或者重新加
 载配置文件。重新加载配置文件你需要在当前配置文件中使用 =M-x load-file= 双击两次
 回车确认默认文件名，或者使用 =M-x eval-buffer= 去执行当前缓冲区的所有 Lisp 命令。
 你也可以使用 =C-x C-e= 来执行某一行的 Lisp 代码。这些可使刚刚修改的配置文件生效。
 当然你也可以将这些函数绑定为快捷键。

**** 插件管理

 使用默认的插件管理系统（可在菜单栏 =Options > Manage Emacs Packages= 中找到）安
 装 [[http://company-mode.github.io/][Company]] 插件，他是一个用于代码补全的插件。它的名字代表补全一切的意思（ *Comp*
 lete *Any* thing）。因为默认的插件管理系统提供的插件十分有限，所以我们会在之后的
 几天中继续将其强化。

 使用的下面的配置将 Company-mode 在全局模式下激活

 #+BEGIN_SRC emacs-lisp
     ; 开启全局 Company 补全
     (global-company-mode 1)
 #+END_SRC

**** Org-mode

 简单的 Org-mode 使用，它可以列出提纲，并方便地使用 =tab= 键来对其进行展开与关闭。
 =C-c C-t= 可以将一个条目转换成一条待办事件。

 #+BEGIN_SRC org
     * 为一级标题
     ** 为二级标题
     *** 为三级标题并以此类推
 #+END_SRC

** 第二天：高级自定义

 视频地址如下

 -  [[http://v.youku.com/v_show/id_XMTUxMzQyODI4MA==.html][优酷视频]]
 -  [[http://pan.baidu.com/s/1c2Cw9ck][百度网盘]]
 -  [[https://youtu.be/l6TzOIlS8Ec][YouTube]]

 *说在最前面*

 如果你想深入学习 Emacs Lisp 可以阅读 GNU 提供的 [[https://www.gnu.org/software/emacs/manual/html_mono/eintr.html][An Introduction to Programming
 in Emacs Lisp]] 。（也可以 =M-x info= 然后选择 Emacs Lisp Intro）

 我们先解决前一天中遇到的一些问题。首先是在对象是一个缓冲区局部变量（Buffer-local
 variable）的时候，比如这里的 =cursor-type= ，我们需要区分 =setq= 与
 =setq-default= ： =setq= 设置当前缓冲区（Buffer）中的变量值， =setq-default= 设
 置的为全局的变量的值（具体内容可以在 [[http://stackoverflow.com/questions/18172728/the-difference-between-setq-and-setq-default-in-emacs-lisp][StackOverflow 找到]]）。下面是一个例子，用于
 设置光标样式的方法。

 #+BEGIN_SRC emacs-lisp
     (setq-default cursor-type 'bar)
 #+END_SRC

 今天我们需要将第一天关闭的自动缩进 (=electric-indent-mode=) 从配置文件中去除，它
 是 Emacs 24.4 中加入的新特性，你可以在这篇[[http://emacsredux.com/blog/2014/01/19/a-peek-at-emacs-24-dot-4-auto-indentation-by-default/][文章]]中找到更多关于它的内容。我们之前关
 闭它是因为，它存在不理想的缩进效果（在 Emacs Lisp 中用分号做注释时
 =fancy-comment= 会造成很远的缩进，其实解决方法是使用 Emacs Lisp 推荐的两个分号而
 不是一个 =;;= ，这样就可以避免这个问题。于是我们也就将其从配置文件中删除）

 因为通常我们的配置文件以及项目文件均使用版本控制系统，所以自动生成的备份文件就显
 得有些多余。我们还可以禁止 Emacs 自动生成备份文件，例如 =init.el~= 。（ =~= 为后
 缀的文件为自动生成的备份文件）我们可以使用下面的方法将其关闭。

 #+BEGIN_SRC emacs-lisp
     (setq make-backup-files nil)
 #+END_SRC

 关于分屏的使用，如果你已经读过 Emacs 自带的教程，现在你应该已经掌握了基本的分屏
 操作方法了。关于分屏的更多内容你可以在[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Split-Window.html][这里]]找到。

 -  =C-x 1= 仅保留当前窗口
 -  =C-x 2= 将当前窗口分到上边
 -  =C-x 3= 将当前窗口分到右边

 使用下面的配置来加入最近打开过文件的选项让我们更快捷的在图形界面的菜单中打开最近
 编辑过的文件。

 #+BEGIN_SRC emacs-lisp
     (require 'recentf)
     (recentf-mode 1)
     (setq recentf-max-menu-item 10)

     ;; 这个快捷键绑定可以用之后的插件 counsel 代替
     ;; (global-set-key (kbd "C-x C-r") 'recentf-open-files)
 #+END_SRC

 =require= 的意思为从文件中加载特性，你可以在杀哥的网站读到关于 Emacs Lisp 库系统
 的更多内容，文章在[[http://ergoemacs.org/emacs/elisp_library_system.html][这里]]。

 使用下面的配置文件将删除功能配置成与其他图形界面的编辑器相同，即当你选中一段文字
 之后输入一个字符会替换掉你选中部分的文字。

 #+BEGIN_SRC emacs-lisp
     (delete-selection-mode 1)
 #+END_SRC

 下面的这些函数可以让你找到不同函数，变量以及快捷键所定义的文件位置。因为非常常用
 所以我们建议将其设置为与查找文档类似的快捷键（如下所示），

 -  =find-function= （ =C-h C-f= ）
 -  =find-variable= （ =C-h C-v= ）
 -  =find-function-on-key= （ =C-h C-k= ）

 在我们进入下一个部分之间让我们来看看使用 =~/.emacs.d/init.el= 与 =~/.emacs= 的区
 别（更多关于他们区别的讨论可在[[http://emacs.stackexchange.com/questions/1/are-there-any-advantages-to-using-emacs-d-init-el-instead-of-emacs][这里]]找到）。简单来说请使用前者，因为它有下面的两个
 优点，

 -  它可以更好将所有 Emacs 相关的文件整合在一个目录内（干净的 =HOME= ，网盘备份等优点）
 -  更好的版本控制

*** Emacs 也很美

 *配置插件源*

 在进行美化之前我们需要配置插件的源（默认的源非常有限），最常使用的是 [[https://melpa.org/][MELPA]]
 （Milkypostman's Emacs Lisp Package Archive）。它有非常多的插件（3000 多个插件）。
 一个插件下载的次数多并不能说明它非常有用，也许这个插件是其他的插件的依赖。在[[https://melpa.org/#/getting-started][这里]]
 你可以找到其安装使用方法。添加源后，我们就可以使用 =M-x package-list-packages=
 来查看所有 MELPA 上的插件了。在表单中可以使用 =I= 来标记安装 =D= 来标记删除，
 =U= 来更新，并用 =X= 来确认。

 你可以直接将下面的代码复制到你的配置文件顶端，从而直接使用 Melpa 作为插件的源。
 你可以将你需要的插件名字写在 =my/packages= 中，Emacs 在启动时会自动下载未被安装
 的插件。


 #+BEGIN_SRC emacs-lisp
     (when (>= emacs-major-version 24)
         (require 'package)
         (package-initialize)
         (setq package-archives '(("gnu"   . "http://elpa.emacs-china.org/gnu/")
                          ("melpa" . "http://elpa.emacs-china.org/melpa/"))))

    ;; 注意 elpa.emacs-china.org 是 Emacs China 中文社区在国内搭建的一个 ELPA 镜像

     ;; cl - Common Lisp Extension
     (require 'cl)

     ;; Add Packages
     (defvar my/packages '(
                    ;; --- Auto-completion ---
                    company
                    ;; --- Better Editor ---
                    hungry-delete
                    swiper
                    counsel
                    smartparens
                    ;; --- Major Mode ---
                    js2-mode
                    ;; --- Minor Mode ---
                    nodejs-repl
                    exec-path-from-shell
                    ;; --- Themes ---
                    monokai-theme
                    ;; solarized-theme
                    ) "Default packages")

     (setq package-selected-packages my/packages)

     (defun my/packages-installed-p ()
         (loop for pkg in my/packages
               when (not (package-installed-p pkg)) do (return nil)
               finally (return t)))

     (unless (my/packages-installed-p)
         (message "%s" "Refreshing package database...")
         (package-refresh-contents)
         (dolist (pkg my/packages)
           (when (not (package-installed-p pkg))
             (package-install pkg))))

     ;; Find Executable Path on OS X
     (when (memq window-system '(mac ns))
       (exec-path-from-shell-initialize))
 #+END_SRC

 关于上面这段配置代码有几个知识点，首先就是这段配置文件中用到了 =loop for ... in=
 ，它来自 =cl= 即 Common Lisp 扩展。 =for= , =in=, =collect= 均为 =cl-loop= 中的
 保留关键字。下面是一些简单的 =cl-loop= 的使用示例：

 #+BEGIN_SRC emacs-lisp
     ;; 遍历每一个缓冲区（Buffer）
     (cl-loop for buf in (buffer-list)
              collect (buffer-file-name buf))

     ;; 寻找 729 的平方根（设置最大为 100 为了防止无限循环）
     (cl-loop for x from 1 to 100
              for y = (* x x)
              until (>= y 729)
              finally return (list x (= y 729)))
 #+END_SRC

 你可以在[[http://www.gnu.org/software/emacs/manual/html_mono/cl.html#Loop-Facility][这里]]找到更多关于循环的使用说明。

 其次就是它使用到了 =quote=, 它其实就是我们之前常常见到的 ='= （单引号）的完全体。
 因为它在 Lisp 中十分常用，所以就提供了简写的方法。

 #+BEGIN_SRC emacs-lisp
     ;; 下面两行的效果完全相同的
     (quote foo)
     'foo
 #+END_SRC

 =quote= 的意思是不要执行后面的内容，返回它原本的内容（具体请参考下面的例子）

 #+BEGIN_SRC emacs-lisp
     (print '(+ 1 1)) ;; -> (+ 1 1)
     (print (+ 1 1))  ;; -> 2
 #+END_SRC

 更多关于 =quote= 的内容可以在[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html][这里]]找到，或者在[[http://stackoverflow.com/questions/134887/when-to-use-quote-in-lisp][这里]]找到 StackOverflow 上对于它的讨论。

 这样我们就可以区分下面三行代码的区别，

 #+BEGIN_SRC emacs-lisp
     ;; 第一种
     (setq package-selected-packages my/packages)
     ;; 第二种
     (setq package-selected-packages 'my/packages)
     ;; 第三种
     (setq package-selected-packages (quote my/packages))
 #+END_SRC

 第一种设置是在缓冲区中设置一个名为 =package-selected-packages= 的变量，将其的值
 设定为 =my/packages= 变量的值。第二种和第三种其实是完全相同的，将一个名为
 =package-selected-packages= 的变量设置为 =my/packages= 。

 我们可以用下面代码将 Emacs 设置为开启默认全屏，

 #+BEGIN_SRC emacs-lisp
     (setq initial-frame-alist (quote ((fullscreen . maximized))))
 #+END_SRC

 我们也可以启用自动括号匹配（Highlight Matching Parenthesis），随后会介绍插件来增
 强这个匹配的功能。你可以在[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Hooks.html][这里]]读到关于钩子的更多信息。

 #+BEGIN_SRC emacs-lisp
     (add-hook 'emacs-lisp-mode-hook 'show-paren-mode)
 #+END_SRC

 高亮当前行，当文本内容很多时可以很容易找到光标的位置。

 #+BEGIN_SRC emacs-lisp
     (global-hl-line-mode 1)
 #+END_SRC

 *安装主题*

 #+BEGIN_SRC emacs-lisp
     (add-to-list my/packages 'monokai-theme)
 #+END_SRC

 然后使用下面的配置使其每次打开编辑器时加载主题，

 #+BEGIN_SRC emacs-lisp
     (load-theme 'monokai 1)
 #+END_SRC

 *推荐插件*

 -  [[http://company-mode.github.io/][company]]
 -  [[https://github.com/nflath/hungry-delete][hungry-delete]]
 -  [[https://github.com/nonsequitur/smex][Smex]] (如果你使用 Counsel 来增强你的 =M-x= ，那么就不需要再安装 Smex 了)
 -  [[https://github.com/abo-abo/swiper][Swiper & Counsel]]
 -  [[https://github.com/Fuco1/smartparens][smartparens]]

 使用 =M-x customize-group= 后选择对应的插件名称，可以进入可视化选项区对指定的插
 件做自定义设置。当选择 Save for future session 后，刚刚做的设计就会被保存在你的
 配置文件（ =init.el= ）中。关于各个插件的安装与使用方法通常都可以在其官方页面找
 到（GitHub Pages 或者是项目仓库中的 README 文件）。我们强烈建议大家在安装这些插
 件后阅读使用方法来更好的将它们使用到你的日常工作当中使效率最大化。

*** JavaScript IDE

 Emacs 提供的默认 JavaScript Major Mode 并不是非常好用。所以我们可以将默认的模式
 替换成 [[https://github.com/mooz/js2-mode][js2-mode]] 一个比默认模式好用的 Major Mode。我们可以通过 MELPA 来下载它，然
 后用下面的代码将其启用。

 #+BEGIN_SRC emacs-lisp
     (setq auto-mode-alist
           (append
            '(("\\.js\\'" . js2-mode))
            auto-mode-alist))
 #+END_SRC

 你可以在[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Auto-Major-Mode.html][这里]]（How Emacs Chooses a Major Mode）找到 Emacs 是如何选择何时该选用何
 种 Major Mode 的方法。

 在这里我们需要知道 =auto-mode-alist= 的作用，这个变量是一个 [[https://www.emacswiki.org/emacs/AssociationList][AssociationList]]，它
 使用正则表达式（REGEXP）的规则来匹配不同类型文件应使用的 Major Mode。 下面是几个
 正则表达式匹配的例子，

 #+BEGIN_SRC emacs-lisp
     (("\\`/tmp/fol/" . text-mode)
      ("\\.texinfo\\'" . texinfo-mode)
      ("\\.texi\\'" . texinfo-mode)
      ("\\.el\\'" . emacs-lisp-mode)
      ("\\.c\\'" . c-mode)
      ("\\.h\\'" . c-mode)
      …)
 #+END_SRC

 下面是如何添加新的模式与对应文件类型的例子（与我们配置 =js2-mode= 时相似的例子），

 #+BEGIN_SRC emacs-lisp
     (setq auto-mode-alist
       (append
	;; File name (within directory) starts with a dot.
	'(("/\\.[^/]*\\'" . fundamental-mode)
          ;; File name has no dot.
          ("/[^\\./]*\\'" . fundamental-mode)
          ;; File name ends in ‘.C’.
          ("\\.C\\'" . c++-mode))
	auto-mode-alist))
 #+END_SRC

 在 =js2-mode= 模式中会提供

 -  语法高亮
 -  语法检查器（Linter）

 执行缓冲区的代码可以使用 =nodejs-repl= 插件，它需要你的机器上已经安装了 NodeJS。
 然而在 Mac OS X 上可能会出现找不到 NodeJS 可执行文件的问题，要解决这个问题你需要
 安装另外一个 =exec-path-from-shell= 的插件并将其启用。

 #+BEGIN_SRC emacs-lisp
     (when (memq window-system '(mac ns))
       (exec-path-from-shell-initialize))
 #+END_SRC

 有了 =nodejs-repl= 我们就可以方便的测试和开发我们的 JavaScript 代码了（你可以在
 [[https://github.com/mooz/js2-mode][这里]]找到更多关于它的使用方法）。

**** Org-mode 进阶

 在 Org-mode 中你可以直接开启新的缓冲区（Buffer）直接用相应的 Major Mode 来编辑代
 码块内的内容。在代码块中使用 =C-c '= 会直接打开对应模式的缓冲区（不仅限于 Lisp）。
 这样就使在 Org-mode 中编辑代码变的十分方便快捷。

 使用 =<s= 然后 Tab 可以直接插入代码块的代码片段（Snippet），更多类似的代码片段
 （Org-mode Easy Templates）可以在[[http://orgmode.org/manual/Easy-Templates.html][这里]]找到。

 #+BEGIN_EXAMPLE
   ,#+BEGIN_SRC emacs-lisp
     ;; Your code goes here
     ;; 你的代码写在这里
   ,#+END_SRC
 #+END_EXAMPLE

 *添加 Org-mode 文本内语法高亮*

 #+BEGIN_SRC emacs-lisp
     (require 'org)
     (setq org-src-fontify-natively t)
 #+END_SRC

 在 Org-mode 中重置有序列表序号可以直接使用 M-<RET> 。

 *Agenda 的使用*

 #+BEGIN_SRC emacs-lisp
     ;; 设置默认 Org Agenda 文件目录
     (setq org-agenda-files '("~/org"))

     ;; 设置 org-agenda 打开快捷键
     (global-set-key (kbd "C-c a") 'org-agenda)
 #+END_SRC

 你只需将你的 =*.org= 文件放入上面所指定的文件夹中就可以开始使用 Agenda
 模式了。

 -  =C-c C-s= 选择想要开始的时间
 -  =C-c C-d= 选择想要结束的时间
 -  =C-c a= 可以打开 Agenda 模式菜单并选择不同的可视方式（ =r= ）

** 第三天：配置文件模块化（上）

 视频地址如下

 - [[http://v.youku.com/v_show/id_XMTUyNzA0MTMxNg%3D%3D.html?f%3D26962151&o%3D1][优酷视频]]
 - [[http://pan.baidu.com/s/1nuJWyLF][百度网盘]]
 - [[https://youtu.be/hL9B2AtcB1w][YouTube]]

*** 多文件存储配置文件(上)

 将不同的配置代码放置到不同的文件中，使其模块化，这让我们的后续维护变得更加简单。
 下面是我们现在的 =~/.emacs.d/= 目录中的样子，

 #+BEGIN_EXAMPLE
 ├── auto-save-list # 自动生成的保存数据
 ├── elpa           # 下载的插件目录
 ├── init.el        # 我们的配置文件
 └── recentf        # 最近访问的文件列表
 #+END_EXAMPLE

 通常我们只保存配置文件和对其进行版本控制，其他的插件均为在第一次使用编辑器时再通
 过网络重新下载，当然你也可以选择将全部配置文件进行版本控制来保证自己时刻拥有最稳
 定的生产环境。

 Elisp 中并没有命名空间（Namespace），换句话说就是所有的变量均为全局变量，所以其
 命名方法就变的非常重要。下面是一个简单的命名规则，

 #+BEGIN_EXAMPLE
 #自定义变量可以使用自己的名字作为命名方式（可以是变量名或者函数名）
 my/XXXX

 #模式命名规则
 ModeName-mode

 #模式内的变量则可以使用
 ModeName-VariableName
 #+END_EXAMPLE

 遵守上面的命名规则可以最大程度的减少命名冲突发生的可能性。

 现在我们想将原本混合在一起的配置文件分为下面的几个模块（每一个模块为一个独立的配
 置文件并将其保存在指定的子目录中），它们分别是

 #+BEGIN_EXAMPLE
 init-packages.el        # 插件管理
 init-ui.el              # 视觉层配置
 init-better-defaults.el # 增强内置功能
 init-keybindings.el     # 快捷键绑定
 init-org.el             # Org 模式相关的全部设定
 custome.el              # 存放使用编辑器接口产生的配置信息
 #+END_EXAMPLE

 下面为将配置文件进行模块化后的目录结构，

 #+BEGIN_EXAMPLE
 ├── init.el
 └── lisp
     ├── custom.el
     ├── init-better-defaults.el
     ├── init-helper.el
     ├── init-keybindings.el
     ├── init-packages.el
     ├── init-ui.el
     └── init-org.el
 #+END_EXAMPLE

 使用模块化配置就可以让我们在之后的配置中迅速的定位与更改配置内容，让整个过程变得
 更有条理也更加高效。

 和之前一样 =init.el= 是配置文件的入口，现在它便成为了所有模块配置文件的入口，所
 以要使用这些模块时，我们需要在其中引用需要加载的模块。下面以 =init-packages.el=
 （此配置为添加插件的模块） 为例，详细说明如何模块化以及应用的方法。

 下面是在模块化配置之前，我们所使用的配置文件 =~/.emacs.d/init.el= 的样子，我们将
 所有的配置代码都放置在了同一个文件中（如下所示）

 下面为 =~/.emacs.d/init.el= 文件的内容

 #+BEGIN_SRC emacs-lisp
 ;;  __        __             __   ___
 ;; |__)  /\  /  ` |__/  /\  / _` |__
 ;; |    /~~\ \__, |  \ /~~\ \__> |___
 ;;                      __   ___        ___      ___
 ;; |\/|  /\  |\ |  /\  / _` |__   |\/| |__  |\ |  |
 ;; |  | /~~\ | \| /~~\ \__> |___  |  | |___ | \|  |
 (when (>= emacs-major-version 24)
     (require 'package)
     (package-initialize)
     (setq package-archives '(("gnu"   . "http://elpa.emacs-china.org/gnu/")
                          ("melpa" . "http://elpa.emacs-china.org/melpa/"))))

 ;; cl - Common Lisp Extension
 (require 'cl)

 ;; Add Packages
 (defvar my/packages '(
			    ;; --- Auto-completion ---
			    company
			    ;; --- Better Editor ---
			    smooth-scrolling
			    hungry-delete
			    swiper
			    counsel
			    smartparens
			    ;; --- Major Mode ---
			    js2-mode
			    markdown-mode
			    ;; --- Minor Mode ---
			    ;; Quick Note Taking
			    deft
			    ;; JavaScript REPL
			    nodejs-repl
			    ;; Find OS X Executable Helper Package
 ;; ...
 #+END_SRC

 之前为了更好的区分不同的区域我使用的方法是使用 ASCII Art 然后再以关键字来做搜索
 跳转，但是这样再编辑工程中依旧十分缓慢和麻烦。于是我们现在要将配置文件全部模块化，
 把不同部分的配置代码放置在不同的配置文件中，并在入口文件（ =~/.emacs.d/init.el=
 ）中依次引用不用的模块。

 下面为 =~/.emacs.d/lisp/init-packages.el= 模块中的代码

 #+BEGIN_SRC emacs-lisp
 ;;  __        __             __   ___
 ;; |__)  /\  /  ` |__/  /\  / _` |__
 ;; |    /~~\ \__, |  \ /~~\ \__> |___
 ;;                      __   ___        ___      ___
 ;; |\/|  /\  |\ |  /\  / _` |__   |\/| |__  |\ |  |
 ;; |  | /~~\ | \| /~~\ \__> |___  |  | |___ | \|  |
 (when (>= emacs-major-version 24)
     (require 'package)
     (package-initialize)
     (setq package-archives '(("gnu"   . "http://elpa.emacs-china.org/gnu/")
                          ("melpa" . "http://elpa.emacs-china.org/melpa/"))))

 ;; cl - Common Lisp Extension
 (require 'cl)

 ;; Add Packages
 (defvar my/packages '(
			    ;; --- Auto-completion ---
			    company
			    ;; --- Better Editor ---
			    smooth-scrolling
			    hungry-delete
			    swiper
			    counsel
			    smartparens
			    popwin
			    ;; --- Major Mode ---
			    js2-mode
			    markdown-mode

 ;; ...

 ;; 文件末尾
 (provide 'init-packages)
 #+END_SRC

 下面为 =~/.emacs.d/init.el= 入口文件中的代码

 #+BEGIN_SRC emacs-lisp
 (package-initialize)

 (add-to-list 'load-path "~/.emacs.d/lisp/")

 ;; Package Management
 ;; -----------------------------------------------------------------
 (require 'init-packages)
 #+END_SRC

 模块化要做的其实非常简单，我们要做的其实就是把某一个更改编辑器某定部分（例如，插
 件管理，显示层，快捷键绑定等）的配置代码写入一个独立的文件中并在末尾为其添加
 =(provide 'modul-name)= (这里我们的模块名为 =init-packages= )使其可以在入口文件
 中被调用，然后再在入口文件中将其引用既可。

 这里需要注意的是，我们需要在入口文件中添加 =(add-to-list 'load-path
 "~/.emacs.d/lisp/")= 这可以让 Emacs 找到需要加载的模块所处的位置。

 更多模块化的配置文件可以在[[https://github.com/zilongshanren/Learning-Emacs/tree/day3][这里]]找到。

*** Major 与 Minor Mode 详解

 在这一节我们将详细介绍 Major Mode 与 Minor Mode 去区别。每一个文件类型都对应一个
 Major Mode，它提供语法高亮以及缩进等基本的编辑支持功能，然后而 Minor Mode 则提供
 其余的增强性的功能（例如 =linum-mode= ）。

 在 Emacs 中，Major Mode 又分为三种，

 - =text-mode= ，用于编辑文本文件
 - =special-mode= ，特殊模式（很少见）
 - =prog-mode= ，所有的编程语言的父模式

 # TODO: Explan what is prog-mode

 在每一个模式（mode）中它的名称与各个变量还有函数都是有特定的命名规则，比如所有的
 模式都被命名为 =ModeName-mode= ，里面所设置的快捷键则为 =ModeName-mode-key-map=
 ，而所有的钩子则会被命名为 =ModeName-mode-hook= 。

 注明：为了保持阅读的完整性，部分第三天的关于默认编辑器优化的内容被移至第四天。

** 第四天：配置文件模块化（下）以及使用优化

 视频地址如下

 - [[http://v.youku.com/v_show/id_XMTUzMDAwMDYwMA%3D%3D.html][优酷视频]]
 - [[http://pan.baidu.com/s/1o8QWrHK][百度网盘]]
 - [[https://youtu.be/IhCOO0R83G8][YouTube]]

*** 配置文件模块化（下）

 在这一部分我们首先需要知道的是什么是 =features= 。在 Emacs 中每一个 =feature= 都
 是一个 Elisp 符号，用于代表一个 Lisp 插件（Package）。

 当一个插件调用 =(provide 'symbol_name)= 函数时，Emacs 就会将这个符号加入到
 =features= 的列表中去。你可以在[[http://ergoemacs.org/emacs/elisp_feature_name.html][这里]]读到更多关于 feature 的内容。

 接着我们需要弄明白的是 =load-file= , =load= , =require= , =autoload= 之间的区别。
 （他们之间区别的链接已经再前面贴过了，你也可以在[[http://ergoemacs.org/emacs/elisp_library_system.html][这里]]找到之前同样的链接）

 简单来说， =load-file= 用于打开某一个指定的文件，用于当你不想让 Emacs 来去决定加
 载某个配置文件时（ =.el= 或者 =.elc= 文件）。

 =load= 搜索 =load-path= 中的路径并打开第一个所找到的匹配文件名的文件。此方法用于
 你预先不知道文件路径的时候。

 =require= 加载还未被加载的插件。首先它会查看变量 =features= 中是否存在所要加载的
 符号如果不存在则使用上面提到的 =load= 将其载入。（有点类似于其他编程语言中的
 =import= ）

 =autoload= 用于仅在函数调用时加载文件，使用此方法可以大大节省编辑器的启动时间。

 # TODO: 补充魔法注释的内容

*** 更好的默认设置

 在这一节我们会配置我们的编辑器使其有更好的使用体验。整个过程就如同搭积木一般，将
 更好的体验建立在已有的功能基础之上。这样的优化使整个过程变得更高效，也更有趣。

 下面的代码可以是 Emacs 自动加载外部修改过的文件。

 #+BEGIN_SRC emacs-lisp
 (global-auto-revert-mode 1)
 #+END_SRC

 使用下面的代码可以关闭自己生产的保存文件（之前我们已经关闭过了 Emacs 自动生产的
 备份文件了，现在是关闭自动保存文件）。

 #+BEGIN_SRC emacs-lisp
 (setq auto-save-default nil)
 #+END_SRC

 如果你发现你在使用中发现了那些编辑行为与你预期的不相符时，你可以通过搜索引擎去寻
 找解决方案然后将其加入你的配置中并打造一个真正属于你的神器！

 =popwin= 插件可以自动将光标移动到，新创建的窗口中。使用下面的代码将其启用，

 #+BEGIN_SRC emacs-lisp
 (require 'popwin)
 (popwin-mode 1)
 #+END_SRC

 也许你并不喜欢听到错误时的“哔哔”的警告提示音，使用下面的代码你可以关闭 Emacs 中的警告音，

 #+BEGIN_SRC emacs-lisp
 (setq ring-bell-function 'ignore)
 #+END_SRC

 每一次当 Emacs 需要与你确认某个命令时需要输入 =(yes or no)= 比较麻烦，所有我们可
 以使用下面的代码，设置一个别名将其简化为只输入 =(y or n)= 。

 #+BEGIN_SRC emacs-lisp
 (fset 'yes-or-no-p 'y-or-n-p)
 #+END_SRC

**** 代码缩进

 =indent-region= 可以帮我们重新缩进所选区域的代码，但是每一次都选中十分麻烦。使用
 下面的代码可以一次重新缩进全部缓冲区的代码。（之后也会介绍更好用的，代码格式美化
 的插件）

 #+BEGIN_SRC emacs-lisp
   (defun indent-buffer()
     (interactive)
     (indent-region (point-min) (point-max)))

   (defun indent-region-or-buffer()
     (interactive)
     (save-excursion
       (if (region-active-p)
           (progn
             (indent-region (region-beginning) (region-end))
             (message "Indent selected region."))
         (progn
           (indent-buffer)
           (message "Indent buffer.")))))
 #+END_SRC

 然后再将其用下面的代码将其绑定为快捷键，第一个 =\= 用于将紧跟的 =\= 进行逃脱（escape）。

 #+BEGIN_SRC emacs-lisp
 (global-set-key (kbd "C-M-\\") 'indent-region-or-buffer)
 #+END_SRC

**** 缩写补全

 使用下面的代码我们可以开启 =abbrev= 模式并定义一个缩写表，每当我们输入下面的缩写
 并以空格结束时，Emacs 就会将其自动展开成为我们所需要的字符串。

 #+BEGIN_SRC emacs-lisp
   (setq-default abbrev-mode t)
   (define-abbrev-table 'global-abbrev-table '(
                                               ;; Shifu
                                               ("8zl" "zilongshanren")
                                               ;; Tudi
                                               ("8lxy" "lixinyang")
                                              ))
 #+END_SRC

 上面的缩写前使用的 =8= 也类似于命名空间的作用，使其不会与我们所常用的字符串冲突。

**** Hippie 补全

 Company 有时候补全功能并不是非常理想，这时就可以使用 Hippie Expand 来完成补全。
 Company Mode 补全效果不理想的原因是在不同的区域中会使用不同的后端函数来完成补全，
 但是当后端补全函数不能被激活时，则补全就不会被激活。


 我们可以将下面的代码加入到我们的配置文件中，来增强 Hippie Expand 的功能，

 #+BEGIN_SRC emacs-lisp
   (setq hippie-expand-try-function-list '(try-expand-debbrev
                                           try-expand-debbrev-all-buffers
                                           try-expand-debbrev-from-kill
                                           try-complete-file-name-partially
                                           try-complete-file-name
                                           try-expand-all-abbrevs
                                           try-expand-list
                                           try-expand-line
                                           try-complete-lisp-symbol-partially
                                           try-complete-lisp-symbol))
 #+END_SRC

 然后将其绑定为快捷键，使我们可以更方便的使用它。

 #+BEGIN_SRC emacs-lisp
 (global-set-key (kbd "s-/") 'hippie-expand)
 #+END_SRC

*** Dired Mode

 Dired Mode 是一个强大的模式它能让我们完成和文件管理相关的所有操作。

 使用 =C-x d= 就可以进入 Dired Mode，这个模式类似于图形界面系统中的资源管理器。你
 可以在其中查看文件和目录的详细信息，对他们进行各种操作，甚至复制粘贴缓冲区中的内
 容。下面是一些常用的操作（下面的所有键均需在 Dired Mode 下使用），

 - =+= 创建目录
 - =g= 刷新目录
 - =C= 拷贝
 - =D= 删除
 - =R= 重命名
 - =d= 标记删除
 - =u= 取消标记
 - =x= 执行所有的标记

 这里有几点可以优化的地方。第一是删除目录的时候 Emacs 会询问是否递归删除或拷贝，
 这也有些麻烦我们可以用下面的配置将其设定为默认递归删除目录（出于安全原因的考虑，
 也许你需要保持此行为。所有文中的配置请务必按需配置）。

 #+BEGIN_SRC emacs-lisp
 (setq dired-recursive-deletes 'always)
 (setq dired-recursive-copies 'always)
 #+END_SRC

 第二是，每一次你进入一个回车进入一个新的目录中是，一个新的缓冲区就会被建立。这使
 得我们的缓冲区列表中充满了大量没有实际意义的记录。我们可以使用下面的代码，让
 Emacs 重用唯一的一个缓冲区作为 Dired Mode 显示专用缓冲区。

 #+BEGIN_SRC emacs-lisp
 (put 'dired-find-alternate-file 'disabled nil)

 ;; 主动加载 Dired Mode
 ;; (require 'dired)
 ;; (defined-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)

 ;; 延迟加载
 (with-eval-after-load 'dired
     (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file))
 #+END_SRC

 使用延迟加载可以使编辑器加载速度有所提升。

 启用 =dired-x= 可以让每一次进入 Dired 模式时，使用新的快捷键 =C-x C-j= 就可以进
 入当前文件夹的所在的路径。

 #+BEGIN_SRC emacs-lisp
 (require 'dired-x)
 #+END_SRC

 使用 =(setq dired-dwin-target 1)= 则可以使当一个窗口（frame）中存在两个分屏
 （window）时，将另一个分屏自动设置成拷贝地址的目标。

 最后如果你是 Mac OS X 的用户，可以安装 =reveal-in-osx-finder= 这个插件（你可以在
 [[https://melpa.org/#/reveal-in-osx-finder][这里]]找到它），它可以将任意文件直接在 Finder 中打开。你想安装这个插件，将其添加至
 第二天的插件列表中即可，下次启动 Emacs 时，它就会自动帮你完成下载。

*** Org-mode 管理 Emacs 配置

 Org-mode 下的文学编程将颠覆你对于 Emacs 的看法。因为我们也可以使用 Org 来管理
 Emacs 的配置文件（笔者和他的师傅其实更倾向于模块管理配置文件）。

 你需要将下面的代码放入配置入口文件（ =init.el= ）中，

 #+BEGIN_SRC emacs-lisp
 (package-initialize)

 (require 'org-install)
 (require 'ob-tangle)
 (org-babel-load-file (expand-file-name "org-file-name.org" user-emacs-directory))
 #+END_SRC

 之后我们需要做的仅仅只是将所有的配置文件放入 Org 模式中的代码块即可，并使用目录
 结构来表述你的配置文件再把它保存在与入口文件相同的目录中即可（文件名为
 =org-file-name.org= ）。Emacs 会提取其中的配置并使其生效。这样做的好处是可以使自
 己和他人更直观的，理解你的配置文件或者代码。

** 第五天：打造前端开发神器

 视频地址如下

 - [[http://pan.baidu.com/s/1slOOWSd][百度网盘]]
 - [[http://v.youku.com/v_show/id_XMTU0NjMyNDg5Ng%3D%3D.html][优酷]]
 - [[https://youtu.be/Tjh5cKAw1Ks][YouTube]]

 照例我们先修复一些现在存在的小问题。首先是自动配对的小问题，在 Emacs Lisp 中我们
 有时候只需要一个 ='= 但是 Emacs 很好心的帮我们做了补全，但这并不是我们需要的。我
 们可以通过下面的代码来让使 Emacs Lisp 在 Emacs 中的编辑变得更方便（可以将其添加
 至 =init-default.el= 配置文件中）。

 #+BEGIN_SRC emacs-lisp
   (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
   (sp-local-pair 'lisp-interaction-mode "'" nil :actions nil)

   ;; 也可以把上面两句合起来
   (sp-local-pair '(emacs-lisp-mode lisp-interaction-mode) "'" nil :actions nil)
 #+END_SRC

 在添加配置代码后重启 Emacs 使其生效。当然这个方法你也可以运用在其他的各个 Major
 Mode 中，如果你不想 Emacs 对某些符号进行类似的自动匹配补全。

 =show-paren-mode= 可以使鼠标在括号上是高亮其所匹配的另一半括号，然而我们想要光标
 在括号内时就高亮包含内容的两个括号，使用下面的代码就可以做到这一点。

 #+BEGIN_SRC emacs-lisp
 (define-advice show-paren-function (:around (fn) fix-show-paren-function)
   "Highlight enclosing parens."
   (cond ((looking-at-p "\\s(") (funcall fn))
         (t (save-excursion
              (ignore-errors (backward-up-list))
              (funcall fn)))))
 #+END_SRC

 Lisp 的宏（Macro）类似于 C++ 中的模板，并可以生产新的代码（你可以在[[http://stackoverflow.com/questions/267862/what-makes-lisp-macros-so-special][这里]]找到更多
 关于宏的讨论）。使用它，我们可以增强某个函数的功能而不去更改这个函数的代码。

 还有一个小问题就是解决在不同系统中的换行符，例如在 DOS 系统下的 =\r(^M)= 换行符，
 这让我们有时候在 Unix 系统中很是头疼，因为它的存在会使版本控制误以为整行的代码都
 被修改过而造成不必要的麻烦。（你可以在[[http://unix.stackexchange.com/questions/32001/what-is-m-and-how-do-i-get-rid-of-it][这里]]找到更多关于 =\r(^M)= 的信息）

 我们用两种方式来处理这个问题，隐藏这个换行符或者将其删除。首先下面是隐藏的方法，

 #+BEGIN_SRC emacs-lisp
   (defun hidden-dos-eol ()
     "Do not show ^M in files containing mixed UNIX and DOS line endings."
     (interactive)
     (unless buffer-display-table
       (setq buffer-display-table (make-display-table)))
     (aset buffer-display-table ?\^M []))
 #+END_SRC

 使用下面的代码则可以定义函数将此换行符删除，

 #+BEGIN_SRC emacs-lisp
   (defun remove-dos-eol ()
     "Replace DOS eolns CR LF with Unix eolns CR"
     (interactive)
     (goto-char (point-min))
     (while (search-forward "\r" nil t) (replace-match "")))
 #+END_SRC

*** web-mode

 Emacs 自带的 HTML Mode 使用起来并不是那么的方便，而 web-mode 则是一个非常常用也
 很强大的用于编辑前端代码的 Major Mode（你可以在[[https://github.com/fxbois/web-mode][这里]]找到更多关于它的信息）。

 首先我们需要安装它，照例我们需要将其添加至我们的插件列表中去。

 #+BEGIN_SRC emacs-lisp
   (defvar xinyang/packages '(
                              ;; 你其他的插件在这里
                              web-mode
                              ) "Default packages")
 #+END_SRC

 在安装完成后我们就可以开始配置它了，首先我们需要做的是将所有的 =*.html= 文件都使
 用 web-mode 来打开。

 #+BEGIN_SRC emacs-lisp
   (setq auto-mode-alist
         (append
          '(("\\.js\\'" . js2-mode))
          '(("\\.html\\'" . web-mode))
          auto-mode-alist))
 #+END_SRC

 这样所有的 HTML 代码在 Emacs 中就会之间启用 web-mode 而非默认的 HTML Mode 了。你
 可以阅读它的[[http://web-mode.org/][文档]]来学习更多 web-mode 详细的使用方法。

 例如使用 =M-;= 就可以注释当前行代码或选中行的代码。

 接下来我们来做更多细节的配置，首先是缩减的大小的设置。因为 web-mode 支持在 HTML
 文件中存在多语言，所以我们可以对不同的语言的缩减做出设置。下面的代码用于设置初始
 的代码缩进，

 #+BEGIN_SRC emacs-lisp
 (defun my-web-mode-indent-setup ()
   (setq web-mode-markup-indent-offset 2) ; web-mode, html tag in html file
   (setq web-mode-css-indent-offset 2)    ; web-mode, css in html file
   (setq web-mode-code-indent-offset 2)   ; web-mode, js code in html file
   )
 (add-hook 'web-mode-hook 'my-web-mode-indent-setup)
 #+END_SRC

 下面的函数可以用于在两个空格和四个空格之间进行切换，

 #+BEGIN_SRC emacs-lisp
 (defun my-toggle-web-indent ()
   (interactive)
   ;; web development
   (if (or (eq major-mode 'js-mode) (eq major-mode 'js2-mode))
       (progn
         (setq js-indent-level (if (= js-indent-level 2) 4 2))
         (setq js2-basic-offset (if (= js2-basic-offset 2) 4 2))))

   (if (eq major-mode 'web-mode)
       (progn (setq web-mode-markup-indent-offset (if (= web-mode-markup-indent-offset 2) 4 2))
              (setq web-mode-css-indent-offset (if (= web-mode-css-indent-offset 2) 4 2))
              (setq web-mode-code-indent-offset (if (= web-mode-code-indent-offset 2) 4 2))))
   (if (eq major-mode 'css-mode)
       (setq css-indent-offset (if (= css-indent-offset 2) 4 2)))

   (setq indent-tabs-mode nil))

 (global-set-key (kbd "C-c t i") 'my-toggle-web-indent)
 #+END_SRC
*** js2-refactor

 js2-refactor 是一个用于重构 JavaScript 的插件，它是一个 Minor Mode，你可以在
 [[https://github.com/magnars/js2-refactor.el][GitHub]] 找到更多关于这个插件的信息。

 我们使用刚刚所提到的方法来安装 js2-refactor 插件。

 在安装完成后，添加一个钩子（Hook）：

 #+BEGIN_SRC emacs-lisp
   (add-hook 'js2-mode-hook #'js2-refactor-mode)
   (js2r-add-keybindings-with-prefix "C-c C-m")
 #+END_SRC

 我们可以使用 =C-c C-m= 然后输入功能前缀，例如 =em= 是 extract-method 的前缀。更
 多的功能和使用方法也可以在上面给出的链接中找到，所有的前缀也可以在[[https://github.com/magnars/js2-refactor.el#refactorings][这里]]找到。

*** 优化 occur 与 imenu

 下面的代码用于配置 Occur Mode 使其默认搜索当前被选中的或者在光标下的字符串：

 #+BEGIN_SRC emacs-lisp
   (defun occur-dwim ()
     "Call `occur' with a sane default."
     (interactive)
     (push (if (region-active-p)
               (buffer-substring-no-properties
		(region-beginning)
		(region-end))
             (let ((sym (thing-at-point 'symbol)))
               (when (stringp sym)
                 (regexp-quote sym))))
           regexp-history)
     (call-interactively 'occur))
   (global-set-key (kbd "M-s o") 'occur-dwim)
 #+END_SRC

 =dwim= 是按我说的做的缩写（Do what I mean）。

 Occur 可以用于显示变量或函数的定义，我们可以通过 popwin 的 customize-group 将定
 义显示设置为右边而不是默认的底部（ =customize-group > popwin > Popup Window
 Position= 设置为 right），也可以在这里对其宽度进行调节。

 Occur 与普通的搜索模式不同的是，它可以使用 Occur-Edit Mode (在弹出的窗口中按 =e=
 进入编辑模式) 对搜索到的结果进行之间的编辑。

 imenu 可以显示当前所有缓冲区的列表，下面的配置可以让其拥有更精确的跳转，

 #+BEGIN_SRC emacs-lisp
   (defun js2-imenu-make-index ()
         (interactive)
         (save-excursion
           ;; (setq imenu-generic-expression '((nil "describe\\(\"\\(.+\\)\"" 1)))
           (imenu--generic-function '(("describe" "\\s-*describe\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*" 1)
                                      ("it" "\\s-*it\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*" 1)
                                      ("test" "\\s-*test\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*" 1)
                                      ("before" "\\s-*before\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*" 1)
                                      ("after" "\\s-*after\\s-*(\\s-*[\"']\\(.+\\)[\"']\\s-*,.*" 1)
                                      ("Function" "function[ \t]+\\([a-zA-Z0-9_$.]+\\)[ \t]*(" 1)
                                      ("Function" "^[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*=[ \t]*function[ \t]*(" 1)
                                      ("Function" "^var[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*=[ \t]*function[ \t]*(" 1)
                                      ("Function" "^[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*()[ \t]*{" 1)
                                      ("Function" "^[ \t]*\\([a-zA-Z0-9_$.]+\\)[ \t]*:[ \t]*function[ \t]*(" 1)
                                      ("Task" "[. \t]task([ \t]*['\"]\\([^'\"]+\\)" 1)))))
   (add-hook 'js2-mode-hook
                 (lambda ()
                   (setq imenu-create-index-function 'js2-imenu-make-index)))

   (global-set-key (kbd "M-s i") 'counsel-imenu)
 #+END_SRC

*** expand-region

 使用同样的方法将 expand-region 添加至我们的插件列表中，重启 Emacs 安装插件。

 再为其绑定一个快捷键，

 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "C-=") 'er/expand-region)
 #+END_SRC

 使用这个插件可以使我们更方便的选中一个区域。（更多使用方法和文档可以在[[https://github.com/magnars/expand-region.el][这里]]找到）

*** iedit

 iedit 是一个可以同时编辑多个区域的插件，它类似 Sublime Text 中的多光标编辑。它的 GitHub 仓库在[[https://github.com/victorhge/iedit][这里]]。

 我们将其绑定快捷键以便更快捷的使用这个模式（ =C-;= 为默认快捷键），

 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "M-s e") 'iedit-mode)
 #+END_SRC

 我们可以使用 Customized-group 来更改其高亮的背景色，将 =highlight= 改为 =region= 。

*** Org 导出

 使用 =C-c C-e= 可以将 Org-mode 文档导出为你需要的格式，例如 HTML 或者 PDF 文件。
 你现在看到的这本教程就是由 Org-mode 所导出生成的。

** 第六天：代码片段与语法检查器

 视频地址如下

 - [[http://pan.baidu.com/s/1miLBw5E][百度网盘]]
 - [[http://v.youku.com/v_show/id_XMTU0NjYwNzQ3Mg%3D%3D.html][优酷]]
 - [[https://www.youtube.com/watch?v%3DWIzWxTc1KUI&featur][YouTube]]

 在开始前我们需要注意的是之前模块化的配置文件 =init-keybindings.el= 应该放在所有
 调用模块的最后面，因为也许在设置快捷键时某些函数还未被加载。

 我们可以使用下面的配置来在 Company-mode 中使用 =C-n= 与 =C-p= 来选择补全项，

 #+BEGIN_SRC emacs-lisp
   (with-eval-after-load 'company
     (define-key company-active-map (kbd "M-n") nil)
     (define-key company-active-map (kbd "M-p") nil)
     (define-key company-active-map (kbd "C-n") #'company-select-next)
     (define-key company-active-map (kbd "C-p") #'company-select-previous))
 #+END_SRC

*** Org-mode 进阶使用

 在学习代码片段和语法检查器（Linter）之前，我们先来学习一下如何使用 Org-mode 来做
 学习笔记和安排工作时间。我们用下面的配置代码来设置一个模板（其中设置了待办事项的
 优先级还有触发键），

 #+BEGIN_SRC emacs-lisp
   (setq org-capture-templates
         '(("t" "Todo" entry (file+headline "~/.emacs.d/gtd.org" "工作安排")
            "* TODO [#B] %?\n  %i\n"
            :empty-lines 1)))
 #+END_SRC

 我们也可以为其绑定一个快捷键，

 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "C-c r") 'org-capture)
 #+END_SRC

 这个功能除了可以记录待办事项还有其他许许多多的功能例如获取将当前浏览器中的
 URL（下面的例子只在 Mac OS X 平台有效）。

 #+BEGIN_SRC emacs-lisp
   (defun YOUR_NAME/retrieve-chrome-current-tab-url()
     "Get the URL of the active tab of the first window"
     (interactive)
         (let ((result (do-applescript
			(concat
                         "set frontmostApplication to path to frontmost application\n"
                         "tell application \"Google Chrome\"\n"
                         " set theUrl to get URL of active tab of first window\n"
                         " set theResult to (get theUrl) \n"
                         "end tell\n"
                         "activate application (frontmostApplication as text)\n"
                         "set links to {}\n"
                         "copy theResult to the end of links\n"
                         "return links as string\n"))))
           (format "%s" (s-chop-suffix "\"" (s-chop-prefix "\"" result)))))
 #+END_SRC

 更多有关 Org-capture 的内容可以在[[http://orgmode.org/manual/Capture.html][这里]]找到。

 Org-pomodoro 是一个番茄时间工作法的插件（更多关于这个工作法的信息可以在[[https://en.wikipedia.org/wiki/Pomodoro_Technique][这里]]找到）。
 它的 GitHub 地址在[[https://github.com/lolownia/org-pomodoro][这里]]。在 =(require 'org-pomodoro)= 后可以通过 Customize-group
 来对其进行设置，包括不同休息种类的时长。

 因为每次保存中文的时候都需要选择解码，我们可以使用下面的配置将文本解码设置默认为 UTF-8，

 #+BEGIN_SRC emacs-lisp
   (set-language-environment "UTF-8")
 #+END_SRC

 当 org-mode 不能生效时，我们需要将与 Org 相关的配置放置于 =with-eval-after-load= 中，

 #+BEGIN_SRC emacs-lisp
   (with-eval-after-load 'org
     ;; Org 模式相关设定
     )
 #+END_SRC

*** 批量修改文件名

 =C-x C-q= 就可以直接在 Dired Mode 中进行编辑，使用之前学的 iedit-mode 和区域选择
 就可以直接对多个文件进行重命名编辑了。

*** 搜索与替换

 全局搜索在我们的编辑工作中是不可缺少的，今天我们介绍的是 ag。它是非常快速的命令
 行搜索工具，它是 Linux 的所有搜索工具中最快的。

 #+BEGIN_EXAMPLE
 ag > pt > ack > grep
 #+END_EXAMPLE

 在使用 ag 前我们需要进行安装，下面是 Mac OS X 与 Ubuntu 下的安装方法，

 #+BEGIN_EXAMPLE
 # Mac OS X 通过 Homebrew 安装
 brew install the_silver_searcher

 # Ubuntu 下安装
 apt-get install silversearcher-ag

 # Windows 下通过 msys2 安装（确保在 path 中）
 pacman -S mingw-w64-i686-ag # 32 位电脑
 pacman -S mingw-w64-x86_64-ag # 64 位电脑
 #+END_EXAMPLE

 安装好 ag 后我们就可以安装 helm-ag 插件了。（它的 GitHub 仓库地址在[[https://github.com/syohex/emacs-helm-ag][这里]]）在安装
 完成后可以为其设置快捷键，

 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "C-c p s") 'helm-do-ag-project-root)
 #+END_SRC

 使用这个插件我们同样可以在缓冲区对搜索到的结果进行直接的修改，这样就可以做到快速
 的搜索与替换。

*** 语法检查器（Linter）

 语法检查器可以在开发动态语言（Interpreted/Dynamic Programming Language）时极大的
 提高你的开发效率，它会实时的检查你的代码并将句法错误（Syntax Error）与静态语义
 （Static Semantic Error）错误进行高亮与提示。

 我们在这里使用的例子是 JavaScript 的语法检查器 eslint 它的安装方法可以在[[https://github.com/eslint/eslint][这里]]找到。

 在安装好语法检查器后就可以安装 flycheck 的插件了，它的 GitHub 的地址在[[https://github.com/flycheck/flycheck][这里]]。

 使用下面的代码可以将 flycheck-mode 在特定模式下激活（下面的例子就是只有在打开
 JavaScript 时才会激活语法检查器），

 #+BEGIN_SRC emacs-lisp
   (add-hook 'js2-mode-hook 'flycheck-mode)
 #+END_SRC

 使用 =flycheck-verify-setup= 可以进行语法检查器的选择。

 eslint 检查器的配置也可以使用项目目录下的 =.eslintrc= 来进行配置，更多配置方法可
 以在[[http://eslint.org/docs/user-guide/configuring][这里]]找到。

*** 代码块

 =yasnippet= 是一个代码块补全的插件（[[https://github.com/capitaomorte/yasnippet][GitHub]] 地址）。使用下面的配置文件将其在所有
 的编程语言的模式中激活。

 #+BEGIN_SRC emacs-lisp
   (yas-reload-all)
   (add-hook 'prog-mode-hook #'yas-minor-mode)
 #+END_SRC

 自定义代码块的方法可以在上面提供的链接中找到。

**** auto-yasnippet

 [[https://github.com/abo-abo/auto-yasnippet][auto-yasnippet]] 也是一个非常好用代码块补全插件。安装并未其设置快捷键，

 #+BEGIN_SRC emacs-lisp
   (global-set-key (kbd "H-w") #'aya-create)
   (global-set-key (kbd "H-y") #'aya-expand)
 #+END_SRC

 简单的使用方法就是使用 =~= 来定义模板，然后调用 =aya-create= 再使用 =aya-expand= 来使用模板。
** 第七天：Evil 模式

 视频地址如下，

 - [[http://pan.baidu.com/s/1dEIlXID][百度网盘]]
 - [[http://v.youku.com/v_show/id_XMTU1NTk4MzUyNA%3D%3D.html][优酷]]
 - [[https://youtu.be/evnnz2jvteQ][YouTube]]

 开始之前我们先将 =C-w= 来使其可以向后删除一个单词，这样就可以与 Shell 中的快捷键操作同步。

 #+BEGIN_SRC emacs-lisp
 (global-set-key (kbd "C-w") 'backward-kill-word)
 #+END_SRC

 如果你不是 Vim 的用户，你可以选择跳过这一天的内容。但是我们强烈建议你花一些时间
 来学习基本的 Vim 操作，即使 Emacs 是你的最爱 Vim 的快捷键也在一定程度会增加你的
 编辑效率。基础的 Vim 操作可以在[[http://www.openvim.com/][这里]]学会。

 Evil 模式中的 State 就相当与 Vim 中的模式，常用的模式有下面几种（后面对于了相应
 的 Emacs 中的 State），

 - Normal Mode -> Normal State
 - Insert Mode -> Insert State
 - Visual Mode -> Visual State
 - Motion Mode -> Motion State

 还有一个 Emacs 中的特殊状态是 Emacs State。

*** Evil 的安装

 照例我们需要将 Evil 插件添加至我们的插件列表中来完成安装。在重启 Emacs 完成安装
 后可以添加下面的代码将其激活。

 #+BEGIN_SRC emacs-lisp
 (evil-mode 1)
 #+END_SRC

 在激活 Evil 模式后就可以，在 Emacs 中使用 Vim 的快捷键了。有一点需要注意 =C-u=
 在 Emacs 中有特殊的功所（Universal args）以能我们可以通过使用 =customize-group=
 来对 Evil 模式进行修改，将 =Evil Want C U Scroll= 设置为开启。

 下面的代码可以将 =insert state map= 中的快捷键清空，使其可以回退（Fallback）到
 Emacs State 中，这样我们之前的 Emacs State 里面定义的 =C-w= 等快捷键就不会被
 =evil insert minor mode state= 所覆盖，

 #+BEGIN_SRC emacs-lisp
 (setcdr evil-insert-state-map nil)
 (define-key evil-insert-state-map [escape] 'evil-normal-state)
 #+END_SRC

 这样你就可以使用 Evil 来在 Emacs 中完成百分之八十作用的快捷键操作了。

 完整的 Evil Mode 的 PDF 版本的操作指南可以在[[https://bytebucket.org/lyro/evil/raw/default/doc/evil.pdf][这里]]找到，建议从 Vim 转 Emacs 的用户
 多次阅读来完整的掌握这个模式的使用方法。

*** Evil 模式插件

**** Leader Key 

 在 Emacs 中使用 Leader Key 可以通过 [[https://github.com/cofi/evil-leader][evil-leader]] 来实现。你需要做的就是在安装后将其激活即可。

  *提示*: 根据[[https://github.com/cofi/evil-leader][cofi/evil-leader]] 的说明，你应该在激活 evil-mode 之前就激活 global-evil-leader-mode，否则 evil-leader 在几个初始缓冲区(scratch, Message,...)上将不生效。

 #+BEGIN_SRC emacs-lisp
 (global-evil-leader-mode)
 #+END_SRC


 Leader Key 可以通过 customize-group 来进行设置（Evil Leader/Leader）。因为之后我
 们会转移至 Spacemacs 所以我们可以将其设置为空格键 =SPC= 。

 在通过下面的配置来设置简单的结合 Leader Key 快捷键组合（我们使用不同的键讲不同的
 功能分组，例如我们使用 =f= 键来做关于文件的操作，使用 =b= 键来做关于缓冲区
 （Buffer）的操作），

 #+BEGIN_SRC emacs-lisp
 (evil-leader/set-key
   "ff" 'find-file
   "bb" 'switch-to-buffer
   "0"  'select-window-0
   "1"  'select-window-1
   "2"  'select-window-2
   "3"  'select-window-3
   "w/" 'split-window-right
   "w-" 'split-window-below
   ":"  'counsel-M-x
   "wM" 'delete-other-windows
   )
 #+END_SRC

 注意上面窗口跳转相关的设置需要 window-numbering 安装后方可生效。

**** Window-numbering 

 这个插件可以让我们快速的使用 Leader Key 与数字键的组合来在多个窗口之间进行跳转。
 它的 GitHub 地址可以在[[https://github.com/nschum/window-numbering.el][这里]]找到。

 下载安装后通过下面的代码可以将其激活，

 #+BEGIN_SRC emacs-lisp
 (window-numbering-mode 1)
 #+END_SRC

**** Evil-Surround

 [[https://github.com/timcharper/evil-surround][Evil-surround]] 是一个 Vim 上非常常用的插件改写的，使用它可以快速的将选中区域进行
 匹配的操作，例如选中区域两边同时进行添加或修改括号，引号等操作。

 下载安装后使用下面的代码将其激活，

 #+BEGIN_SRC emacs-lisp
 (require 'evil-surround)
 (global-evil-surround-mode)
 #+END_SRC

 简单的使用方法就是在选中所选区域后，使用 =S(= 来将选中区域包括在括号之中。如果想
 将括号改变成 ="= 可以在选中后使用 =cs("=


**** Evil-nerd-commenter

 这是一个快速添加与取消注释的插件，它的 GitHub 地址在[[https://github.com/redguardtoo/evil-nerd-commenter][这里]]。

 使用下面代码可以将其激活，

 #+BEGIN_SRC emacs-lisp
 (evilnc-default-hotkeys)
 #+END_SRC

 使用下面的代码将其与 Evil 模式进行绑定，这里我们选择使用 =,/= 作为快捷键。

 #+BEGIN_SRC emacs-lisp
 (define-key evil-normal-state-map (kbd ",/") 'evilnc-comment-or-uncomment-lines)
 (define-key evil-visual-state-map (kbd ",/") 'evilnc-comment-or-uncomment-lines)
 #+END_SRC

**** Which-key

 [[https://github.com/justbur/emacs-which-key][which-key]] 可以显示当前组合键下所有可以使用的全部组合键的选项。使用这个插件可以很
 好的解决快捷键太多的问题，我们无需在记忆任何快捷键，而是根据自己的需求使用不同分
 组的快捷键后再在其中去需找自己需要的功能。

 在下载后可以使用下面的代码进行激活，

 #+BEGIN_SRC emacs-lisp
 (which-key-mode 1)
 #+END_SRC

*** Org Mode 中的搜索

 =C-c a= 中可以根据提示使用 =s= 来进行关键字所搜。使用 =t= 则可以进行代办事项的搜索。



** 第八天：Cask 介绍与实践

 视频地址如下:

 - [[http://pan.baidu.com/s/1o83r1vc][百度网盘]]
 - [[http://v.youku.com/v_show/id_XMTU3MzEyNDkxNg==.html][优酷]]
 - [[https://youtu.be/B7jx8kJIbnY][YouTube]]

 什么是 Cask:

 Cask 是一个 Emacs Lisp 的项目管理工具.

*** Cask 的安装

 Cask 的地址: [[https://github.com/cask/cask][Cask]]

 可以使用如下命令安装 Cask:

 #+BEGIN_SRC shell
 curl -fsSL https://raw.githubusercontent.com/cask/cask/master/go | python
 #+END_SRC

 安装过程中 Cask 将会进行 Bootstrap, 安装一些包到~/.emacs.d 目录中.

 安装完成之后需要将 Cask 的可执行文件目录加入到 PATH 中.

 可以看到, Cask 的安装过程在 ~/.emacs.d 中新建了一个 .Cask 目录.

 安装 Pallet: Pallet 是一个基于 Cask 的包管理工具, 可以使用 Emacs 的包安装方式安装.

 然后使用以下代码启用 Pallet:

 #+BEGIN_SRC emacs-lisp
 (pallet-mode)  
 (pallet-init)    ; 在.emacs.d 中生成一个 Cask 文件, 写入源与现有包
 (pallet-install) ; 将 elpa 中的 package 拷贝到.Cask/<you version>/elpa 目录中
 #+END_SRC

 然后在配置文件中加入以下代码(在其他包加载之前) :

 #+BEGIN_SRC emacs-lisp
 (require 'cask "<path-to-cask>/cask.el")
 (cask-initialize)    ; 类似于 package-initialize
 (require 'pallet)
 (pallet-mode t)      ; 激活 pallet, 在安装包时将 Cask 文件写入相应信息
 #+END_SRC

 具体使用方式见文档: [[https://github.com/rdallasgray/pallet][Pallet]]

*** 为何使用 Cask

 - 使用 Cask 文件保存包的信息, 可以通过 *Cask install* 自动安装
 - 当有多个版本的 Emacs 时, 将各版本的包单独存放

*** 故障排除

**** Emacs24.5 时不能安装 *let-alist*
   
 解决方案: 将 Gnu 的源加入源列表中, 示例代码如下(加入 Cask 文件)

 #+BEGIN_SRC emacs-lisp
 (source "gnu" "http://elpa.zilongshanren.com/gnu/")
 #+END_SRC

**** 在 Emacs24.5 中没有定义 define-advice

 define-advice 是一个 Emacs25 中加入的宏, 在 Emacs24 中不能使用, 可以使用
 *defadvice* 代替:

 #+BEGIN_SRC emacs-lisp
 (defadvice show-paren-function (around fix-show-paren-function activate)
   (cond ((looking-at-p "\\s(") ad-do-it)
	 (t (save-excursion
	      (ignore-errors (backward-up-list))
	      ad-do-it)))
   )
 #+END_SRC

 而且使用 defadvice 相比 define-advice 还有一个优点: 

 使用 define-advice 定义的代码, 当在 Normal 模式时光标两边的括号不会高亮, 而使用
 defadvice 可以.

** 第九天：Macro 与 Use-package

 视频地址如下:

 - [[http://pan.baidu.com/s/1c1Gnkcw][百度网盘]]
 - [[http://v.youku.com/v_show/id_XMTU4MDU2NjE3Ng==.html][优酷]]
 - [[https://youtu.be/AnHP4rNiKSE][YouTube]]

 这次主要介绍 Emacs Lisp 中的宏(Macro)以及 Use-package 插件.

*** Macro

**** 什么是 Macro

 宏是一种可以生成代码的代码. 类比与 C 语言中的宏以及 C++中的模板. 先看一个简单的例子:

 #+BEGIN_SRC emacs-lisp
   (defmacro inc (var)
     (list 'setq var (list '1+ var)))

   (setq my-var 1)
   (setq my-var (+ 1 my-var))

   (macroexpand '(inc my-var))
 #+END_SRC

 以上这个宏的作用是将变量的值+1. 执行以上代码之后, *my-var* 的结果为 2.

 可以使用 macroexpand 获得宏展开的结果, 如以上代码结果为:

 #+BEGIN_SRC emacs-lisp
   (setq my-var (1+ my-var))
 #+END_SRC

 我们也可以使用函数来实现相同的功能, 但 Macro 与函数有以下两个区别:

 1. 宏的参数并不会被马上求值, 解释器会先展开宏, 宏展开之后解释器才会执行宏展开的
    结果; 而函数的参数会马上求值
 2. 宏的执行结果是一个表达式, 该表达式会立即被解释器执行; 而函数的结果是一个值

**** backquote

 backquote 是指反引号(`), 即键盘上数字 1 左边的键.

 当在 Emacs 输入 backquote 时会插入两个反引号, 可以使用以下代码关闭这个功能:

 #+BEGIN_SRC emacs-lisp
   (sp-local-pair 'emacs-lisp-mode "`" nil :actions nil)
 #+END_SRC

 先看以下例子来体会 backquote 的作用:

 #+BEGIN_SRC emacs-lisp
   (defun my-print (number)
     (message "This is a number: %d" number))

   (my-print 2)               ; 1. output= This is a number: 2
   (my-print (+ 2 3))         ; 2. output= This is a number: 5

   (quote (+ 1 1))
   ;; return a list= (+ 1 1)

   (defmacro my-print-2 (number)
     `(message "This is a number: %d" ,number))

   (my-print-2 2)             ; 3. output= This is a number: 2
   (my-print-2 (+ 2 3))       ; 4. output= This is a number: 5

   (setq my-var 2)
   (inc my-var)

   (defmacro inc2 (var1 var2)
     (list 'progn (list 'inc var1) (list 'inc var2)))

   (macroexpand '(inc2 my-var my-var))
   (macroexpand-all '(inc2 my-var my-var))
 #+END_SRC

 quote 的作用是返回后面的表达式, 不对表达式进行求值. 所以以下代码:

 #+BEGIN_SRC emacs-lisp
   (quote (+ 1 1))
   ;; return a list= (+ 1 1)
 #+END_SRC

 并没有对表达式 *(+ 1 1)* 进行求值返回 2, 而是返回一个 list.

 backquote 的作用与 quote 相似, 同样不对后面的表达式求值, 但是当 backquote 在宏中
 与逗号(,)一起使用时, 用逗号修饰的变量将进行求值.

 例如以下代码:

 #+BEGIN_SRC emacs-lisp
   (defmacro my-print-2 (number)
     `(message "This is a number: %d" ,number))

   (pp (macroexpand '(my-print-2 (+ 2 3))))
   (my-print-2 (+ 2 3))
 #+END_SRC

 当输出 message 且 number 不带逗号时, *my-print-2* 的执行将提示错误. 因为宏不对参
 数进行求值, 所以以上宏展开相当于:

 #+BEGIN_SRC emacs-lisp
 (message "This is a number:" number)
 #+END_SRC

 因为我们没有定义 number 变量, 所以执行出错.

 而如果加入逗号, 则在宏展开时会对变量 *number* 进行求值, 展开结果为:

 #+BEGIN_SRC emacs-lisp
   (message "This is a number: %d" (+ 2 3))
 #+END_SRC

 在调试宏的过程中, 可以使用 *macroexpand* 和 *macroexpand-all* 获取宏展开的结果.

 关于 backquote 的更多讨论, 可以见以下地址: [[https://emacs-china.org/t/lisp/357][lisp 中的`与，是怎么用的？]]

**** 为什么使用宏

 使用宏可以减少重复的代码, 以下是一个使用宏来定义函数的例子:

 #+BEGIN_SRC emacs-lisp
   (defun prelude-search (query-url prompt)
     "Open the search url constructed with the QUERY-URL.
   PROMPT sets the `read-string prompt."
     (browse-url
      (concat query-url
              (url-hexify-string
               (if mark-active
                   (buffer-substring (region-beginning) (region-end))
                 (read-string prompt))))))

   (defmacro prelude-install-search-engine (search-engine-name search-engine-url search-engine-prompt)                   ; #1
     "Given some information regarding a search engine, install the interactive command to search through them"    
     `(defun ,(intern (format "prelude-%s" search-engine-name)) ()                                                       ; #2
          ,(format "Search %s with a query or region if any." search-engine-name)                                        ; #3
          (interactive)
          (prelude-search ,search-engine-url ,search-engine-prompt)))                                                    ; #4

   (prelude-install-search-engine "google"     "http://www.google.com/search?q="              "Google: ")                ; #5
   (prelude-install-search-engine "youtube"    "http://www.youtube.com/results?search_query=" "Search YouTube: ")
   (prelude-install-search-engine "github"     "https://github.com/search?q="                 "Search GitHub: ")
   (prelude-install-search-engine "duckduckgo" "https://duckduckgo.com/?t=lm&q="              "Search DuckDuckGo: ")
 #+END_SRC

 下面对以上代码进行讲解:

 第#1 行, 通过 *prelude-install-search-engine* 定义了一个需要 3 个参数的宏, 这个
 宏的作用是生成一个函数.

 第#2 行, 通过 *intern* 生成一个符号作为函数名, 名称为　*prelude-xxx* , 其中 xxx
 为第一个参数的值.

 第#3 行, 生成了这个函数的描述. 

 第#4 行, 调用 *prelude-search* 函数进行搜索处理.

 第#5 行, 调用这个宏定义了一个名为　*prelude-google* 的函数.

 从以上代码可以知道, 我们利用宏生成了４个名称不同的函数, 避免了手动编写函数的问题
 (因为这４个函数的代码非常相似, 根据 DRY 原则应该尽量避免做这种重复工作).

 关于宏的更多内容, 可以阅读 *Paul Graham* 的著作　[[http://www.paulgraham.com/onlisp.html][《On Lisp》]]

 #+RESULTS:
 : prelude-duckduckgo


*** Use-package

**** 简介

 Use-package 是一个宏, 它能让你将一个包的 *require* 和它的相关的初始化等配置组织
 在一起, 避免对同一个包的配置代码散落在不同的文件中.

 Use-package 的更多信息参见以下地址: [[https://github.com/jwiegley/use-package][Use-package]]

**** 一些简单的用法

***** 更安全的 require

 在 Emacs 中, 当我们要引入一个包时, 通常会使用以下代码:

 #+BEGIN_SRC emacs-lisp
   (require 'package-name)
 #+END_SRC

 但是当 *package-name* 不在 *load-path* 中时, 以上代码会抛出错误. 使用
 *Use-package* 可以避免:

 #+BEGIN_SRC emacs-lisp
   (use-package package-name)
 #+END_SRC

 以上代码展开的结果如下:

 #+BEGIN_SRC emacs-lisp
   (if
       (not
	(require 'package-name nil 't))
       (ignore
	(message
         (format "Cannot load %s" 'package-name))))
 #+END_SRC

 可以看到, *Use-package* 使用 *ignore* 来避免抛出错误, 这样当某个包不存在时,
 *eamcs* 也能够正常启动.

***** 将配置集中

 当我们引入某个包时, 有可能需要定义一些与这个包相关的变量, 使用 *Use-package* 实
 现这个需求如下:

 #+BEGIN_SRC emacs-lisp
   (use-package package-name
     :init
     (setq my-var1 "xxx")
     :config
     (progn
       (setq my-var2 "xxx")
       (setq my-var3 "xxx")
       )
     )
 #+END_SRC

 在上例中, *init* 后的代码在包的 require 之前执行, 如果这段代码出错则跳过包的 require.

 *config* 后的代码在包的 require 之后执行.

 *init* 与 *config* 之后只能接单个表达式语句, 如果需要执行多个语句, 可以用 *progn* .

***** autoload 

 使用 require 时会引入这个包, 但是当你的包很多时会影响启动速度. 而使用 autoload
 则可以在真正需要这个包时再 require, 提高启动速度, 避免无谓的 require.

 使用 *Use-package* 可以轻松的实现这个功能:

 #+BEGIN_SRC emacs-lisp
   (use-package package-name
     :commands
     (global-company-mode)
     :defer t
     )
 #+END_SRC

 使用 *commands* 可以让 package 延迟加载, 如以上代码会首先判断 package 的符号是否
 存在, 如果存在则在 *package-name* 的路径下加载. *defer* 也可以让 *package-name*
 进行延迟加载.

***** 键绑定

 在之前的代码中, 如果我们需要绑定一个键, 需要使用 *global-key-bind* 或
 *define-key* 实现, 而使用*Use-package* 实现更简单:

 #+BEGIN_SRC emacs-lisp
   (use-package color-moccur
     :commands (isearch-moccur isearch-all)
     :bind (("M-s O" . moccur)
            :map isearch-mode-map
            ("M-o" . isearch-moccur)
            ("M-O" . isearch-moccur-all))
     :init
     (setq isearch-lazy-highlight t)
     :config
     (use-package moccur-edit))
 #+END_SRC



**** 为什么使用 Use-package

 1. Use-package 能让相关的配置更为集中, 避免配置分散带来的维护困难
 2. Use-package 有完善的错误处理, 使配置代码更为健壮
 3. Spacemacs 也大量使用了 Use-package

** 第十天: Company-mode 与 auto-completion

 视频地址如下:

 - [[http://pan.baidu.com/s/1hsyfnXq][百度网盘]]
 - [[http://v.youku.com/v_show/id_XMTYwMzc0NDg0OA==.html][优酷]]
 - [[https://youtu.be/wgam0sXuMdU][YouTube]]

 内容概要:

 1. 给出 Cask 和 Use-package 的简单示例
 2. 详细介绍 Company-mode 的工作原理, 各种 backend 及其用法

 扩展阅读:

 1. [[http://sixty-north.com/blog/writing-the-simplest-emacs-company-mode-backend][编写一个简单的 comopany backend]]
 2. [[https://www.emacswiki.org/emacs/CompanyMode][Company Mode Emacs wiki]]

*** 升级 Package 之后有 BUG 怎么办

 有些时候我们将一个 Package 升级到最新的版本(例如 github 上最新的 commit), 而该版本可能会存在一些 BUG, 这就会导致我们的配置不能使用.

 如果我们使用 stable 版本的 Package(例如使用 github 上最新的 release), 就可以尽量地减少因为升级包之后的 BUG 导致配置不可用的情况.

 另一种解决方式是使用 Cask 进行包管理, 举例如下:

 首先我们添加一个包, 例如我们编辑 Cask 文件, 添加 monokai-theme :

 #+BEGIN_SRC emacs-lisp
   (depends-on "monokai-theme"
               :git "https://github.com/oneKelvinSmith/monokai-emacs/releases"
               :ref "02c5f5d")
 #+END_SRC

 然后启动 emacs, 但是出现了 BUG. 
 这时我们可以直接将 ref 的值修改为最新的 commit, Cask 即会更新这个包, 而不用等待 melpa 对包进行更新.

*** Use-package 的更多用法

 如果我们启用 *exec-path-from-shell* , 在 emacs 启动时可能会提示 *PATH* 变量重复定义, 解决方案如下:

 #+BEGIN_SRC emacs-lisp
   (use-package exec-path-from-shell
     :ensure t
     :if (and (eq system-type 'darwin) (display-graphic-p))
     :config
     (progn
       (when (string-match-p "/zsh$" (getenv "SHELL"))
         ;; Use a non-interactive login shell.  A login shell, because my
         ;; environment variables are mostly set in `.zprofile'.
         (setq exec-path-from-shell-arguments '("-l")))

       (exec-path-from-shell-initialize)
       )
     )

   ;; (use-package monokai-theme
   ;; :ensure t)
 #+END_SRC

 其中 if 子句可以确定启用 Package 的条件, 在 config 子句中向 *exec-path-from-shell-arguments* 即可消除这个警告.

 ensure 子句来确保 Package 被安装. 如果要使用 stable 版, 则添加以下子句:

 #+BEGIN_SRC emacs-lisp
   :pin melpa-stable
 #+END_SRC

*** Company-mode 的工作原理

 Company-mode 需要配合后端使用, 所有的 backend 都保存在 *company-backends* 这个变量中, 例如在我的环境中该变量值如下:

 #+BEGIN_SRC emacs-lisp
   (company-capf
    (company-dabbrev-code company-gtags company-etags company-keywords)
    company-files
    company-dabbrev
    )
 #+END_SRC

 *company-backends*变量的值是一个列表, 其中的每一项都是一个后端或 Group Backend.

 Company-mode 会依次调用该变量中的 backend, 并判断该 backend 是否合适当前 Buffer, 直到找到一个合适的补全后端.

 在进行补全项选择的时候, 我们也可以在 mode-line 中看到是使用的哪一个后端.

 1. company-dabbrev: 将当前打开的所有 buffer 中的关键字作为补全显示(默认不使用 scratch buffer).
 2. company-files: 补全路径.

 如果在补全过程中取消了补全, 也可以使用命令再次开启补全. 例如 *company-files* 补全方式就可以使用 company-files 函数开启.

 在输入英文时可以使用 company-ispell 进行输入提示.

*** 为什么有时 Python 的补全 不工作

 有时在编写 Python 代码的时候补全不能工作, 这时我们可以先查看 *company-backends* 的值, 查看是否需要安装 *company-anaconda* 用于补全.

 在 Mac 系统中, 如果 anaconda-mode 的安装过程出现错误, 可以参照以下解决方案: [[https://emacs-china.org/t/mac-python-anaconda-mode/207][Mac 上面编辑 python 的时候安装 anaconda-mode 出错]]

 然后确保在 *company-backends* 中有 *company-anaconda* 这个后端即可. 可以使用如下代码:

 #+BEGIN_SRC emacs-lisp
   (add-hook 'python-mode-hook
             (lambda ()
               (set (make-local-variable 'company-backends) '(company-anaconda))))
 #+END_SRC

 以上代码在 python-mode 被激活时设置 *company-backends* 的变量值为 (company-anaconda), 则在编辑 python 代码时就可以使用 anaconda-mode 进行补全.

 在 emacs 中有两种补全方式:
 1. 如 company-files 等, 根据关键字等进行补全, 只需要 emacs 自己进行一些处理即可得到补全数据;
 2. 如 company-anaconda 等, 需要使用客户端-服务端模式, 补全后端需要服务端的配合才能得到补全数据.

 在进行编程时, 一般使用第二种补全后端, 例如 编写 python 代码使用 company-anaconda, 编写 C/C++代码使用 company-ycmd, 编写 javascript 代码使用 company-tern.

 上述示例代码开启 company-anaconda 时有一个缺点, 比如当我们在 python 的注释时没法使用补全, 因为补全后端只有 company-anaconda, 在注释时不工作. 我们可以将 dabbrev 加入后端列表:

 #+BEGIN_SRC emacs-lisp
   (add-hook 'python-mode-hook
             (lambda ()
               (set (make-local-variable 'company-backends) '(company-anaconda company-dabbrev))))
 #+END_SRC

 当 company-anaconda 不合适时使用 company-dabbrev 进行补全, 即可满足上述需求.

*** Group Backend

 company-dabbrev-code: 类似于 company-dabbrev, 但是 dabbrev 对代码和注释都进行补全, dabbrev-code 只补全代码.

 假设我们的配置代码如下:

 #+BEGIN_SRC emacs-lisp
   (add-hook 'python-mode-hook
             (lambda ()
               (set (make-local-variable 'company-backends) '((company-anaconda company-dabbrev-code)
                                                              company-dabbrev)))
             )
 #+END_SRC

 如果我们在注释中出现了 xxx 这个字符串, 在编写 python 代码时 xxx 不会出现在补全选项中. 因为在此时会先匹配到 company-anaconda, 并不会进入 company-dabbrev. 
 而因为 company-anaconda 是一个 Group Backend, 所以 company-dabbrev-code 的补全数据会出现在补全列表中.
*** 怎样写一个简单的补全后端

 因为视频时间关系, 大家可以去阅读以下文章:

 [[http://sixty-north.com/blog/writing-the-simplest-emacs-company-mode-backend][Writing the Simplest Emacs company-mode Backend]]

 实现方式简单介绍如下:

 1. 定义一个补全数据列表
 2. 定义一个补全函数, 返回对应输入的补全数据

 更多的内容可以查看该文档, 同时在网页右侧的链接中有更多的详细内容.
** 第十一天: Spacemacs 简介及安装

 视频地址如下:

 - [[http://pan.baidu.com/s/1eRTHBLC][百度网盘]]
 - [[http://v.youku.com/v_show/id_XMTYxMzYyNjc4MA==.html][优酷]]
 - [[https://youtu.be/etLqMM5nmqI][Youtube]]

 从今天的内容开始介绍 Spacemacs. 地址: [[https://github.com/syl20bnr/spacemacs][Spacemacs]]

 今天的内容包括:

 1. 如何安装 Spacemacs
 2. 一些简单的配置, 以及 package 管理
 3. 管理自己的配置

*** 安装 Spacemacs

 安装 Spacemacs 非常简单, 只需要将 github 上的仓库克隆即可, 即执行以下命令(如有必要可以先备份以前的配置):

 #+BEGIN_SRC shell
   cd ~
   mv .emacs.d .emacs.d.bak
   mv .emacs .emacs.bak
   git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d
 #+END_SRC

 在克隆完成后直接运行 Emacs. 
 在第一次使用 Spacemacs 时需要下载一些 Package, 然后在 Bootstrap 完成之后你需要进行如下一些配置:

 1. 使用哪种编辑方式, 包括 vim 方式(默认) 以及 emacs 方式.
 2. 使用哪种 Spacemacs distribution. 包括标准版(默认)以及基础版. 区别在于标准版包含非常多的功能, 而基础版只包含核心功能.

 在完成以上两个配置之后, 就会在 HOME 目录生成一个 ~/.spacemacs 配置文件. 
 然后 Spacemacs 会进行进一步的初始化, 下载更多的需要的 Package. 
 如果你需要使用 [[http://elpa.emacs-china.org/][emacs-china]] 的配置源, 此时可以终止 emacs, 然后在~/.spacemacs 中的 dotspacemacs/user-init 函数中加入以下代码:

 #+BEGIN_SRC emacs-lisp
   (setq configuration-layer--elpa-archives
         '(("melpa-cn" . "http://elpa.zilongshanren.com/melpa/")
           ("org-cn"   . "http://elpa.zilongshanren.com/org/")
           ("gnu-cn"   . "http://elpa.zilongshanren.com/gnu/")))
 #+END_SRC

 重新启动 emacs, 等待 Spacemacs 完成安装即可.

 如果你需要更方便的管理你自己的配置, 可以创建 ~/.spacemacs.d 目录, 然后将 ~/.spacemacs 文件移动到该目录中并重命名为 init.el.

 在 Spacemacs 中的操作方式如下:

 1. 按下 *SPC f j* 打开 dired 目录
 2. 按下按键 + , 创建 ~/.spacemacs.d 目录
 3. 将光标移动到 .spacemacs 文件上, 按下 R, 将该文件移动到 .spacemacs.d 目录中
 4. 进入 .spacemacs.d 目录, 将光标移动到 .spacemacs 文件上, 按下 R, 将该文件重命名为 init.el
 5. 按下 qq 退出 dired

 然后启动 emacs 即可.

 使用这种方式管理配置, 你可以将自己的配置集中到 ~/.spacemacs.d 目录中, 更容易进行统一管理. 你也可以将自己的配置 push 到 github 上.

*** 添加内置的 layer

 在安装完成 Spacemacs 之后, 按下 *SPC f e d* 打开 ~/.spacemacs 文件, 修改 *dotspacemacs-configuration-layers* 变量的值, 
 将 auto-completion, better-defaults, emacs-lisp, git, markdown, org, spell-checking, syntax-checking 等 layer 加入列表.

 然后退出 emacs 再重启, 或者按下 *SPC f e R* 安装需要的 package.

*** 一些简单的配置

**** 启动时全屏显示

 在 dotspacemacs/init 函数中, 将 dotspacemacs-fullscreen-at-startup 变量设置为 t 即可. 代码如下:

 #+BEGIN_SRC emacs-lisp
   ;; If non nil the frame is maximized when Emacs starts up.
   ;; Takes effect only if `dotspacemacs-fullscreen-at-startup' is nil.
   ;; (default nil) (Emacs 24.4+ only)
   dotspacemacs-maximized-at-startup t
 #+END_SRC

**** ivy layer

 将 ivy 加入 *dotspacemacs-configuration-layers* 列表中. 按下 *CTRL s* 使用 swiper 可以进行搜索.

**** 查看 layer 下的 文档信息

 按下 *SPC h SPC* 即会弹出一个信息窗口, 可以从窗口中选择具体的 layer 或者其他信息进行查看.

**** 删除安装的 package

 只需要将需要删除的 package 名称加入到 *dotspacemacs-excluded-packages* 变量中, 在下一次启动 emacs 时即会删除该 package.
 示例代码如下:

 #+BEGIN_SRC emacs-lisp
   ;; A list of packages and/or extensions that will not be install and loaded.
   dotspacemacs-excluded-packages '(vi-tilde-fringe)
 #+END_SRC

**** 安装 package

 在 Spacemacs 中安装 package 时最好不要使用 *package-install*, 因为这样安装的 package 会在下一次启动时被删除.

 Spacemacs 提供了一个方式, 你只需将需要安装的 package 加入到 *dotspacemacs-additional-package* 变量中即可, 
 示例代码如下:

 #+BEGIN_SRC emacs-lisp
   ;; List of additional packages that will be installed without being
   ;; wrapped in a layer. If you need some configuration for these
   ;; packages, then consider creating a layer. You can also put the
   ;; configuration in `dotspacemacs/user-config'.
   dotspacemacs-additional-packages '(youdao-dictionary)
 #+END_SRC
**** 配置 customize-group

 如果使用 customize-group 对配置进行了修改, 你可以以下代码将生成的 *custom.el* 配置文件纳入 ~/.spacemacs.d 目录中进行统一管理:

 #+BEGIN_SRC emacs-lisp
   (setq custom-file (expand-file-name "custom.el" dotspacemacs-directory))
   (load custom-file 'no-error 'no-message)
 #+END_SRC

**** 修改主题

 只需修改 *dotspacemacs-themes* 变量的值, 将主题加入列表即可. 在列表中靠前的主题会优先使用.
 示例代码如下:

 #+BEGIN_SRC emacs-lisp
   ;; List of themes, the first of the list is loaded when spacemacs starts.
   ;; Press <SPC> T n to cycle to the next theme in the list (works great
   ;; with 2 themes variants, one dark and one light)
   dotspacemacs-themes '(
                         monokai
                         ;; spacemacs-dark
                         ;; spacemacs-light
                         ;; solarized-light
                         solarized-dark
                         ;; leuven
                         ;; monokai
                         ;; zenburn
                         )
 #+END_SRC

** 第十二天: 创建你的第一个 Spacemacs Layer

 视频地址如下:

 - [[http://pan.baidu.com/s/1mi1vZTI][百度网盘]]
 - [[http://v.youku.com/v_show/id_XMTYyODgxNjU0OA==.html][优酷]]
 - [[https://youtu.be/qQqpWWjub6A][YouTube]]

 主要内容:

 1. 如何更新 Spacemacs, 同步官方 develop 分支及注意事项
 2. Layer 的 variables 变量及使用方法
 3. 如何创建自己的 Layer
 4. 如何定制 modeline
 5. evlified state

*** 如何更新 Spacemacs

 可以通过 git 的方式来更新代码, 假设我们使用的是 develop 分支:

 #+BEGIN_SRC shell
   git checkout develop
   git fetch upstream
   git merge upstream/develop
 #+END_SRC

 一般来说, 如果你不熟悉 emacs 并且你的 Spacemacs 配置能够正常工作, 则不需要频繁的更新代码, 以避免更新之后配置不能使用.

*** variables 变量

 每一个 layer 都可以配置一些变量, 可以通过 *SPC h SPC* 然后输入 layer 名称, 点击对应的选项即可打开该 layer 的 README.org 文件.
 然后按下 SPC f j 进入 dired 模式, 选择 config.el 文件打开, 该文件中即定义了该 layer 的变量.

 例如 better-default layer 的变量如下:

 #+BEGIN_SRC emacs-lisp
   (defvar better-defaults-move-to-beginning-of-code-first t
     "when t, first stroke of C-a will move the cursor to the beginning of code.
   When nil, first stroke will go to the beginning of line.
   Subsequent strokes will toggle between beginning of line and beginning of code.")

   (defvar better-defaults-move-to-end-of-code-first nil
     "when t, first stroke of C-e will move the cursor to the end of code (before comments).
   When nil, first stroke will go to the end of line (after comments).
   Subsequent strokes will toggle between end of line and end of code.")
 #+END_SRC

 要配置使用这些变量, 可以在启用 layer 时使用如下的代码:

 #+BEGIN_SRC emacs-lisp
   (better-defaults :variables
                    better-defaults-move-to-end-of-code-first t)
 #+END_SRC

*** 定制 modeline

 在 emacs25.1 中, 该版本的 modeline 和以前版本不同, 可以通过如下方式将 modeline 修改为以前的显示形状:

 在 dotspacemacs/user-config 中加入如下代码:

 #+BEGIN_SRC emacs-lisp
   (setq ns-use-srgb-colorspace nil)
 #+END_SRC

*** 创建自己的 layer

 假设我们需要创建一个 layer, 名叫 zilongshanren, 并且在 layer 下包含一个名叫 youdao-dictionary 的 package.

 首先利用 spacemacs 提供的函数创建 layer. 按下 M-x 并且输入 configuration-layer/create-layer, 然后选择路径 ~/.spacemacs.d,
 确定创建 README, 然后我们就可以看到 layer 创建成功.

 每一个 layer 的结构如下:

 #+BEGIN_EXAMPLE
     [layer_name]
       |__ [local]
       | |__ [package 1]
       | |     ...
       | |__ [package n]
       |-- layers.el
       |__ packages.el
       |__ funcs.el
       |__ config.el
       |__ keybindings.el

     [] = directory
 #+END_EXAMPLE

 即每一个 layer 目录下都可以包含 layers.el, packages.el 等文件, 以及一个名叫 local 的目录.

 每一个文件的内容描述如下:

 | 文件名          | 用处                                                                                        |
 |----------------+--------------------------------------------------------------------------------------------------|
 | layers.el      | 申明一些额外的 layer 依赖 |
 | packages.el    | 一些 layer 使用到的 package 以及相关配置函数 |
 | funcs.el       | 定义一些 layer 层次的函数, 即全局函数 |
 | config.el      | layer 的配置, 此处定义的配置可以在 .spacemacs 中申明 layer 时进行配置, 也可以定义 emacs 的默认配置 |
 | keybindings.el | 快捷键配置 |

 现在我们可以把 youdao-dictionary 加入到 layer 中, 编辑 packages.el:

 #+BEGIN_SRC emacs-lisp

   ;; 添加 package
   (defconst zilongshanren-packages
     '(youdao-dictionary)
     )

   ;; 初始化 package
   ;; 可以使用 , d m 快捷键, 然后按下 e 展开宏
   (defun zilongshanren/init-youdao-dictionary ()
     (use-package youdao-dictionary
       :defer t
       :init
       (spacemacs/set-leader-keys "oy" 'youdao-dictionary-search-at-point+)
       )
     )
 #+END_SRC

 编辑 config.el 文件:

 #+BEGIN_SRC emacs-lisp
   ;; 开启行号显示
   (global-linum-mode t)

   ;; 定义快捷键
   (global-set-key (kbd "M-s o") 'occur-dwim)

   ;; 将 occur 的 buffer 中的光标移动方式修改为 HJKL
   (evilified-state-evilify-map occur-mode-map
     :mode occur-mode)
 #+END_SRC

 编辑 keybindings.el 文件:

 #+BEGIN_SRC emacs-lisp
   ;; dwin = do what i mean.
   (defun occur-dwim ()
     "Call `occur' with a sane default."
     (interactive)
     (push (if (region-active-p)
               (buffer-substring-no-properties
		(region-beginning)
		(region-end))
             (let ((sym (thing-at-point 'symbol)))
               (when (stringp sym)
                 (regexp-quote sym))))
           regexp-history)
     (call-interactively 'occur))
 #+END_SRC

 然后将 zilongshanren 加到 *dotspacemacs-configuration-layers* 变量中, 即可让 layer 配置生效.

*** 文档

 spacemacs 的文档保存在 doc 目录下, 包含有 CONVENTIONS.org, DOCUMENTATION.org 等文档文件, 建议大家多多阅读.

** 第十三天: 定制你的 Layer

 视频地址如下:

 - [[http://pan.baidu.com/s/1kVroHCj][百度网盘]]
 - [[http://v.youku.com/v_show/id_XMTYyOTcyNjk0NA==.html][优酷]]
 - [[https://youtu.be/RMofkN3IcKE][Youtube]]

 主要内容:

 1. 修复上一期视频中 occur-mode 启动的问题
 2. 修复 ivy0.8 导致的问题, 同时简单探讨了一下今后如何避免和处理类似的问题
 3. 介绍 post-init 和 pre-init 的用法, 介绍了如何定制 spacemacs 的 company-mode
 4. 介绍 layers.el 文件, 演示该文件的作用
 5. 介绍 layer 的 package 的 location 变量, 演示了如何从 github 获取并安装 package 的方法

*** 修复上一期视频中的配置问题

 在之前的配置代码中, 如果我们启动 emacs 会出现以下错误:

 #+BEGIN_EXAMPLE
 Symbol's function definition is void: evilified-state-evilify-map
 #+END_EXAMPLE

 这是因为这个符号在 config.el 中使用的时候还是空的, 我们可以通过以下方式修复, 编辑 config.el 文件, 将以下代码移动到 dotspacemacs/user-init 函数中:

 #+BEGIN_SRC emacs-lisp
   (evilified-state-evilify-map occur-mode-map
     :mode occur-mmode)
 #+END_SRC

*** 修复 ivy0.8 的问题

 在 ivy 升级到0.8版本时, 对其中一个API的返回值进行了修改:

 #+BEGIN_SRC emacs-lisp
   (let (res)
     (ivy-with
      '(ivy-read "test: "
                 '(("one" . 1) ("three" . 3))
                 :action (lambda (x) (setq res x)))
      "t C-m")
     res)
   ;; =>
   ;; ("three" . 3)
 #+END_SRC

 在之前的版本中, 这个函数的返回值是 3, 在0.8版本中被修改为了一个列表. 如果要修复这个问题, 我们需要在使用返回值的时候加上 cdr, 具体的修改可以查看[[https://github.com/syl20bnr/spacemacs/pull/6478][fix break API changes for ivy 0.8]].

*** post-init 和 pre-init

 有一些 mode 已经安装, 例如 company-mode 已经被 auto-completion layer 安装, 如果这时我们还想对该 mode 进行一些定制, 那么我们可以这样处理:

 1. 在我们的 layer 中添加这个包

 #+BEGIN_SRC emacs-lisp
     ;; 添加 package
     (defconst zilongshanren-packages
       '(youdao-dictionary
         company  ; 添加 company package
         )
       )
 #+END_SRC

 2. 然后定义一个 post-init 函数

 #+BEGIN_SRC emacs-lisp
   ;; 定制 company-mode
   (defun zilongshanren/post-init-company ()
     (setq company-minimum-prefix-length 1)
     )
 #+END_SRC

 然后重启 emacs 即可以看到定制的效果.

 对于 package 的三个函数: pre-init, init, post-init, spacemacs是按照这个顺序来依次调用的.

*** location

 在安装 package 时, 我们如果只输入 package 的名字, 那么默认是从 melpa 下载安装的. 如果我们想自定义 package 的安装地址, 那么我们就可以使用 location 变量.

**** 自带 package

 例如我们使用一个自带的 occur package:

 #+BEGIN_SRC emacs-lisp
   ;; 自定义 package 安装地址
   (defconst zilongshanren-packages
     '(youdao-dictionary
       (occur-mode :location built-in)
       )
     )

   ;; 初始化 occur mode
   (defun zilongshanren/init-occur-mode ()
     (evilified-state-evilify-map occur-mode-map
       :mode occur-mmode)
     )
 #+END_SRC

**** 从 github 安装

 例如我们从 github 安装 gulpjs package:

 #+BEGIN_SRC emacs-lisp
   ;; 自定义 package 安装地址
   (defconst zilongshanren-packages
     '(youdao-dictionary
       (occur-mode :location built-in)
       (gulpjs :location (recipe :fetcher github :repo "zilongshanren/emacs-gulpjs"))
       )
     )

   (defun zilongshanren/init-gulpjs ()
     (use-package gulpjs
       :init)
     )
 #+END_SRC

 在 emacs 启动时就会从 github 上下载 guiljs package 并安装到本地.

*** layers.el

 如果我们需要对某些 layer 中的 package 配置进行大量的重写, 那么我们可以移除这个 layer 的某个 package. 我们可以通过 layers.el 来实现这一点, 例如移除 chinese layer 的 youdao-dictionary package:

 #+BEGIN_SRC emacs-lisp
   (configuration-layer/remove-layer 'youdao-dictionary)
 #+END_SRC

 然后我们可以在自己的 layer 中添加这个 package, 然后对它进行定制.
 在这种情况下, spacemacs 不会在 chinese layer 中加载 youdao-dictionary 这个 package, 而是在我们的 layer 中加载这个 package, 以实现对 spacemacs 内置的package 的定制.

** 第十四天: 文件和 Buffer 操作

 视频地址如下:

 - [[http://pan.baidu.com/s/1slMRuot][百度网盘]]
 - [[http://v.youku.com/v_show/id_XMTY0NjUwMTM5Mg==.html][优酷]]
 - [[https://youtu.be/85g3defJP6M][Youtube]]

 主要内容:

 1. 我的配置和 spacemacs配置的一些不同点
 2. 文件相关操作
 3. Buffer 相关操作
 4. Dired

*** 不同点

 从今天的视频开始, 将使用 [[https://github.com/zilongshanren/spacemacs-private][子龙山人的配置]] 来讲解视频. 这份配置对 spacemacs 的定制有两个不同点:

 - 没有使用官方的 modeline, 而是采用自己定制的
 - 排除掉了大量的作者认为对他没有作用的 package, 因为这些 package 确实不经常使用, 反而可能导致一些 BUG 或者导致 spacemacs 启动或使用过程中变慢

*** 文件相关操作

 1. SPC p f

   在当前的项目中查找文件, 类似于 vim 中的 Ctrl-p. 在作者的配置中, 该快捷键被绑定到了以下函数:

   #+BEGIN_SRC emacs-lisp
     (defun zilongshanren/open-file-with-projectile-or-counsel-git ()
       (interactive)
       (if (zilongshanren/vcs-project-root)
           (counsel-git)
         (if (projectile-project-p)
             (projectile-find-file)
           (ido-find-file))))
   #+END_SRC

   该函数会针对不同的项目类型使用不同的查找方式:

   - 如果是 git 项目, 那么使用 counsel-git 来查找文件, 不使用 projectile 的原因是 counsel-git 更快
   - 如果是 projectile 项目, 即在项目的根目录中存在 .projectile 文件, 那么使用 projectile-find-file 来查找文件
   - 否则使用 ido-fine-file 来查找文件

 2. SPC f f

   从当前目录开始查找文件. 在作者的配置中同时启用了 ivy-layer 和 helm-layer, 默认使用的是 helm 来查找文件.

 3. SPC f L

   使用 helm-locate 来在当前系统中查找文件.

 4. SPC f l

   查找文件并使用 literal 的方式来打开文件, 使用 literal 方式打开的文件不会附加编码信息, 例如 utf-8 编码中可能存在的 BOM 头信息, 使用 literal 模式即可以看到 BOM头.

 5. SPC f h

   查找文件并使用二进制的方式来打开文件, 可以使用 C-c C-c 回到之前的模式.

 6. SPC f o

   使用外部程序打开文件.

 7. SPC f E

   使用 sudo 来编辑文件, 当某些文件是只读的时候可以采用这种方式来编辑文件.

 8. SPC f D

   删除当前的文件和 buffer.

 9. SPC f j

   以当前文件的目录打开 dired buffer.

 10. SPC f r

   使用 ivy 打开最近文件列表.

 11. SPC f R

   重命名当前文件.

 12. SPC f v

   添加 local variables, 可以通过这个功能给项目做一些特殊的设置.
   例如按下 SPC f v, 然后选择 add-dir-local-variable, 选择 org-mode, 再选择org-highlight-links 变量, 此时 emacs 会在当前文件的目录下生成一个 .dir-locals.el 文件, 内容如下:

   #+BEGIN_SRC emacs-lisp
   ;;; Directory Local Variables
   ;;; For more information see (info "(emacs) Directory Variables")

   ((org-mode
     (org-highlight-links)))
   #+END_SRC

   这个文件中的代码会在当前目录下的所有文件 buffer 中生效.

 13. SPC f y

   拷贝当前文件的全路径.

 14. SPC f a d

   列出最近访问的目录, 使用命令行工具 fasd 实现.

 15. SPC f C d/u

   将当前文件的编码转换为 DOS/UNIX 编码.

 16. SPC f e d

   打开 .spacemacs 或 .spacemacs.d/init.el 文件.

 17. SPC f e i

   打开 .emacs 或 .emacs.d/init.el 文件.

 18. SPC f e l

   打开系统中已经安装的 el 文件.

 19. SPC f c

   复制文件.

 20. SPC f b

   打开标签.

 21. SPC f s/S

   保存当前 buffer 或 所有 buffer.

*** buffer 相关操作

 1. SPC b .

   打开 Buffer Selection Transient State, 在该模式下可以进行更多的操作, 由 hydra 提供.

 2. SPC b b

   切换到已经打开的 buffer.

 3. SPC b d

   关闭一个 buffer.

 4. SPC b f

   在 finder 中打开当前文件, 只在 Mac系统下生效.

 5. SPC b B/i

   以类似 Dired Mode 的形式打开 buffer 列表, 在这个列表中可以执行和 Dired Mode 类似的操作.

 6. SPC b h

   进入 \*spacemacs\* buffer.

 7. SPC b k

   使用正则表达式来删除 buffer.

 8. SPC b N

   新建一个 buffer.

 9. SPC b m

   删除除当前 buffer 外的所有 buffer.

 10. SPC b R

   使用 emacs 自动备份的文件恢复文件.

 11. SPC b s

   跳转到 scratch buffer.

 12. SPC b w

   关闭/打开 buffer 的 read-only.

 13. SPC b Y

   复制整个 buffer 的内容.

 14. SPC b P

   将剪切板的内容粘贴到整个 buffer.

 15. SPC <tab>

   在当前 buffer 和上一个打开的 buffer 中进行切换.

*** Dired

 在第四天的内容中已经讲解过 Dired Mode 的操作, 具体可以查看 [[https://book.emacs-china.org/#orgheadline22][Dired Mode]].

** 第十五天: layout, windows 和 project 相关

 视频地址如下:

 - [[http://pan.baidu.com/s/1miMvDji][百度网盘]]
 - [[http://v.youku.com/v_show/id_XMTY0NzUxOTI2NA==.html][优酷]]
 - [[https://www.youtube.com/watch?v=vt7FQO9HpBU&list=PL-61yFRAEMlXDnsm3VHfrAm4oT6vVylRG&index=8][Youtube]]

 主要内容:

 1. Layout 相关操作
 2. Window 相关操作
 3. project 相关操作

*** Layout 相关操作

 1. SPC l L

   加载 layout 文件

 2. SPC l l
   
   在 layout 之间切换

 3. SPC l s

   将 layout 保存到文件

 4. SPC l <tab>

   在当前 layout 和上一个 layout 之间切换

 5. SPC l o

   配置 layout

 6. SPC l R

   重命名 layout

 7. SPC l ?

   显示更多的与 layout 相关的命令

*** Window 相关操作

 1. SPC w -

   上下拆分窗口

 2. SPC w /

   左右拆分窗口

 3. SPC w .
   
   显示更多的与 window micro state 的相关的命令

 4. SPC w 2/3

   左右显示 2/3 个窗口

 5. SPC w =

   将窗口均等分

 6. SPC w b

   切换到 minibuffer

 7. SPC w d

   删除当前窗口

 8. SPC w h/j/k/l

   向 左/下/上/右 移动窗口

 9. SPC w m
   
   最大化显示当前窗口

 10. SPC W H/J/K/L

   将当前窗口向 左/下/上/右 移动

 11. SPC w u/U

   取消/重置上次操作

 12. SPC w o

   切换到其他 frame

 13. SPC w F

   创建一个新的 frame

 14. SPC w 1/2/3/4

   切换到对应的编号的窗口

 15. SPC w w

   依次切换到其他窗口

 16. SPC w W

   使用字母标识需要跳转的窗口, 并按下字母进行跳转

 17. SPC t g

   将当前显示的窗口与其他窗口进行黄金分割显示

 18. SPC t -

   开启/关闭 将光标始终显示在中心行

*** project 相关操作

 1. SPC p f

   在当前 project 中查找并打开文件

 2. SPC p b

   在当前 project 中查找打开的 buffer

 3. SPC p p

   切换到其他的 project

 4. SPC p l
   
   切换到其他的 project 并创建一个新的 layout

 5. find-file-in-project

   这是一个插件, 支持全平台. 目前绑定在 SUPER f 快捷键上.

*** 更多内容

 对 Spacemacs 中的快捷键操作就介绍到这里, 更多的快捷键介绍可以到 [[https://www.youtube.com/playlist?list=PLrJ2YN5y27KLhd3yNs2dR8_inqtEiEweE][Spacemacs ABC]] 去查看.

** 第十六天: 使用 ctags 和 company-etags

 视频地址如下:

 - [[http://pan.baidu.com/s/1hr4CYBq][百度网盘]]
 - [[http://v.youku.com/v_show/id_XMTY1Njc1MjUxNg==.html][优酷]]
 - [[https://www.youtube.com/watch?v=afWk8DBOY68][Youtube]]

 主要内容:

 这期视频主要介绍 ctags 和 company-mode 的使用.

*** 为什么使用 ctags

 ctags 是一个开源的, 可以方便的对大型代码库进行索引的软件, 在使用 ctags 生成 tag 之后就可以非常方便的在这些 tag 中进行跳转.
 因为有些编程语言, 例如 javascript 或者 lua, 它们不能进行精确的语义补全, 在有 ctags 进行索引补全的情况下也可以方便编写代码.

 在之前也介绍过 term-mode, 也可以做到一些语义补全. 但是它也有一些缺点:

 1. 配置方式复杂, 对于比较大的项目的配置比较有难度
 2. 有些时候不能得到想要的补全结果

 之前作者使用 YCMD 来对 C/C++ 代码进行补全, 但是它不太稳定, 现在已经切换为 ctags 来进行补全, 对于调试和 profile 会使用 IDE 进行操作.

*** 如何配置 ctags

 首先新建一个 testJs-ctags 目录, 然后在该目录下新建 a.js 以及 b.js 两个文件:

 #+BEGIN_SRC shell
   mkdir testJs-ctags
   cd testJs-ctags
   touch a.js
   touch b.js
 #+END_SRC

 然后编辑 a.js 的内容如下:

 #+BEGIN_SRC javascript
   var func1 = function () {
       console.log("func1");
   };

   var func2 = function () {
   };
 #+END_SRC

 然后在 b.js 中的补全中可以显示处 func1 和 func2 的补全提示的. 为了更方便的讲解之后的内容, 我们可以查看使用的补全的后端: 输入 M-x, diminish-undo, 选择 company-mode, 这样在 modeline 就可以看到 company-mode 的具体信息.

 再次输入 fun 等待弹出补全提示, 在补全选项中上下移动, 可以看到使用的补全后端包括 dabbrev-code 和 etags 等, 如果我们关闭 a.js 的 buffer, 就不会出现 func1 和 func2 的补全选项.

 在之前的操作中, 我们并没有生成 ctags, 为什么也能使用 ctags 补全呢? 我们可以使用 SPC h d v, 然后输出 tags-table-list 来查看该变量的值, 当前的值是指向作者 cocos目录下的 TAGS 文件.
 使用以下代码清空该值:

 #+BEGIN_SRC emacs-lisp
   (setq-default tags-table-list nil)
 #+END_SRC

 然后再次尝试补全, 这时就不会使用 ctags 补全了.

 那么如何生成 ctags 补全的文件呢? 使用以下命令即可:

 #+BEGIN_SRC shell
   cd testJs-ctags
   ctags -e a.js
   # 针对目录
   # ctags -eR foldername
 #+END_SRC

 company-etags 在进行补全的时候, 会从变量 tags-table-list 值的文件列表中去查找 tags, 而且 tags 是不区分语言的.

 如果需要手动加载 TAGS 文件, 那么可以调用 visit-tags-table 命令. 而在打开一个文件时, ctags 会从文件所在的目录进行查找, 一直到根目录, 加载所找到的 TAGS 文件.

*** 如何高效的使用 ctags

**** 自动重新生成 TAGS 文件

 在使用 ctags 的过程中, 如果文件的内容被改变, 那么需要重新生成 TAGS 文件, 以便 ctags 的补全结果更精确. 作者实现了一个函数来自动加载必须的 TAGS 文件:

 #+BEGIN_SRC emacs-lisp
   (defun my-setup-develop-environment ()
     (interactive)
     (when (my-project-name-contains-substring "guanghui")
       (cond
	((my-project-name-contains-substring "cocos2d-x")
         ;; C++ project don't need html tags
         (setq tags-table-list (list (my-create-tags-if-needed "~/cocos2d-x/cocos"))))
	((my-project-name-contains-substring "Github/fireball")
         (message "load tags for fireball engine repo...")
         ;; html project donot need C++ tags
         (setq tags-table-list (list (my-create-tags-if-needed "~/Github/fireball/engine/cocos2d")))))))
 #+END_SRC

 有另外一个工具函数, 当保存文件时会自动的重新生成 TAGS:

 #+BEGIN_SRC emacs-lisp
   (defun my-auto-update-tags-when-save (prefix)
     (interactive "P")
     (cond
      ((not my-tags-updated-time)
       (setq my-tags-updated-time (current-time)))

      ((and (not prefix)
            (< (- (float-time (current-time)) (float-time my-tags-updated-time)) 300))
       ;; < 300 seconds
       (message "no need to update the tags")
       )
      (t
       (setq my-tags-updated-time (current-time))
       (my-update-tags)
       (message "updated tags after %d seconds." (- (float-time (current-time)) (float-time my-tags-updated-time))))))
 #+END_SRC

 可以将 my-auto-udpate-tags-when-save 函数加入 after-save-hook 中, 或者绑定到快捷键上.

**** 配置规则来生成更多的 TAGS

 ctags 自身也有一个配置文件, 可以在该文件中定义规则来更好的生成 TAGS, 一个配置文件的示例如下:

 #+BEGIN_EXAMPLE
   --exclude=*.svn*
   --exclude=*.git*
   --exclude=*tmp*
   --exclude=.#*
   --tag-relative=yes
   --recurse=yes

   --langdef=js

   --regex-js=/[ \t.]([A-Z][A-Z0-9._$]+)[ \t]*[=:][ \t]*([0-9"'\[\{]|null)/\1/n,constant/

   --langdef=css
   --langmap=css:.css
   --regex-css=/^[ \t]*\.([A-Za-z0-9_-]+)/.\1/c,class,classes/
 #+END_EXAMPLE

 在配置文件中可以使用 --exclude 来忽略文件或路径, 使用 --langdef 来定义哪些文件属于 js 文件, 使用 --regex-js 来定义 TAGS 生成时的匹配规则.
 这些匹配规则中可以使用正则表达式来提取内容生成 TAGS.

**** 使用 etags-select 来浏览项目

 在有 TAGS 之后, 可以使用 ctags 来方便的浏览文件内容.
 例如在某个函数名上点击 [, g], 然后选择 etags-select-find-tag-at-point, 这时会把所有相关的内容列出到 buffer 中, 然后可以选择想要跳转的位置跳转过去.

*** 最后的思考

 company-etags 不能对所有的 mode 进行补全, 例如在 org-mode 中默认是不使用 company-etags 的.
 因为在 company-etags.el 文件中有如下的代码:

 #+BEGIN_SRC emacs-lisp
   (defvar company-etags-modes '(prog-mode c-mode objc-mode c++-mode java-mode
                                           jde-mode pascal-mode perl-mode python-mode))
 #+END_SRC

 在该变量中定义了可以使用 company-etags 的 mode, 将 org-mode 加入该变量的值中即可在 org-mode 使用 company-etags 进行补全.

 ctags 支持上百种语言, 学会使用 ctags 能够提交效率.

* org-hacks
#+BEGIN_SRC 
#+TITLE:      Org ad hoc code, quick hacks and workarounds
#+AUTHOR:     Worg people
#+EMAIL:      mdl AT imapmail DOT org
#+OPTIONS:    H:3 num:nil toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t TeX:t LaTeX:t skip:nil d:(HIDE) tags:not-in-toc
#+STARTUP:    align fold nodlcheck hidestars oddeven lognotestate
#+SEQ_TODO:   TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
#+TAGS:       Write(w) Update(u) Fix(f) Check(c)
#+LANGUAGE:   en
#+PRIORITIES: A C B
#+CATEGORY:   worg
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-light.min.css" />

# This file is the default header for new Org files in Worg.  Feel free
# to tailor it to your needs.
#+END_SRC
[[file:index.org][{Back to Worg's index}]]

This page is for ad hoc bits of code. Feel free to add quick hacks and
workaround. Go crazy.

** Hacking Org: Working within Org-mode.
*** Org Agenda

**** Picking up a random task in the global TODO list

 Tony day [[http://mid.gmane.org/m2zk19l1me.fsf%2540gmail.com][shared]] [[https://gist.github.com/4343164][this gist]] to pick up a
 random task.

*** Building and Managing Org
**** Generating autoloads and Compiling Org without make
     :PROPERTIES:
     :CUSTOM_ID: compiling-org-without-make
     :END:

 #+index: Compilation!without make

   Compilation is optional, but you _must_ update the autoloads file
   each time you update org, even when you run org uncompiled!

   Starting with Org 7.9 you'll find functions for creating the
   autoload files and do byte-compilation in =mk/org-fixup.el=.  When
   you execute the commands below, your current directory must be where
   org has been unpacked into, in other words the file =README= should
   be found in your current directory and the directories =lisp= and
   =etc= should be subdirectories of it.  The command =emacs= should be
   found in your =PATH= and start the Emacs version you are using.  To
   make just the autoloads file do:
   : emacs -batch -Q -L lisp -l ../mk/org-fixup -f org-make-autoloads
   To make the autoloads file and byte-compile org:
   : emacs -batch -Q -L lisp -l ../mk/org-fixup -f org-make-autoloads-compile
   To make the autoloads file and byte-compile all of org again:
   : emacs -batch -Q -L lisp -l ../mk/org-fixup -f org-make-autoloads-compile-force
   If you are not using Git, you'll have to make fake version strings
   first if =org-version.el= is not already available (if it is, you
   could also edit the version strings there).
   : emacs -batch -Q -L lisp -l ../mk/org-fixup \
   : --eval '(let ((org-fake-release "7.9.1")(org-fake-git-version "7.9.1-fake"))\
   : (org-make-autoloads))'
   The above assumes a
   POSIX shell for its quoting.  Windows =CMD.exe= has quite different
   quoting rules and this won't work, so your other option is to start
   Emacs like this
   : emacs -Q -L lisp -l ../mk/org-fixup
   then paste the following into the =*scratch*= buffer
 #+BEGIN_SRC emacs-lisp
   (let ((org-fake-release     "7.9.1")
         (org-fake-git-version "7.9.1-fake"))
     (org-make-autoloads))
 #+END_SRC
   position the cursor after the closing paren and press =C-j= or =C-x
   C-e= to evaluate the form.  Of course you can replace
   =org-make-autoloads= with =org-make-autoloads-compile= or even
   =org-make-autoloads-compile-force= if you wish with both variants.

   For *older org versions only* (that do not yet have
   =mk/org-fixup.el=), you can use the definitions below.  To use
   this function, adjust the variables =my/org-lisp-directory= and
   =my/org-compile-sources= to suit your needs.  If you have
   byte-compiled org, but want to run org uncompiled again, just remove
   all =*.elc= files in the =lisp/= directory, set
   =my/org-compile-sources= to =nil=.

 #+BEGIN_SRC emacs-lisp
   (defvar my/org-lisp-directory "~/.emacs.d/org/lisp/"
     "Directory where your org-mode files live.")
  
   (defvar my/org-compile-sources t
     "If `nil', never compile org-sources. `my/compile-org' will only create
   the autoloads file `org-loaddefs.el' then. If `t', compile the sources, too.")
  
   ;; Customize: (must end with a slash!)
   (setq my/org-lisp-directory "~/.emacs.d/org/lisp/")
  
   ;; Customize:
   (setq  my/org-compile-sources t)
  
   (defun my/compile-org(&optional directory)
     "Generate autoloads file org-loaddefs.el.  Optionally compile
      all *.el files that come with org-mode."
     (interactive)
     (defun my/compile-org()
       "Generate autoloads file org-loaddefs.el.  Optionally compile
	all *.el files that come with org-mode."
       (interactive)
       (let ((dirlisp (file-name-directory my/org-lisp-directory)))
         (add-to-list 'load-path dirlisp)
         (require 'autoload)
         (let ((generated-autoload-file (concat dirlisp "org-loaddefs.el")))
           ;; create the org-loaddefs file
           (update-directory-autoloads dirlisp)
           (when my/org-compile-sources
             ;; optionally byte-compile
             (byte-recompile-directory dirlisp 0 'force)))))
   #+END_SRC
**** Reload Org

 #+index: Initialization!Reload

 As of Org version 6.23b (released Sunday Feb 22, 2009) there is a new
 function to reload org files.

 Normally you want to use the compiled files since they are faster.
 If you update your org files you can easily reload them with

 : M-x org-reload

 If you run into a bug and want to generate a useful backtrace you can
 reload the source files instead of the compiled files with

 : C-u M-x org-reload

 and turn on the "Enter Debugger On Error" option.  Redo the action
 that generates the error and cut and paste the resulting backtrace.
 To switch back to the compiled version just reload again with

 : M-x org-reload

**** Check for possibly problematic old link escapes
     :PROPERTIES:
     :CUSTOM_ID: check-old-link-escapes
     :END:
 #+index: Link!Escape
 Starting with version 7.5 Org uses [[http://en.wikipedia.org/wiki/Percent-encoding][percent escaping]] more consistently
 and with a modified algorithm to determine which characters to escape
 and how.

 As a side effect this modified behaviour might break existing links if
 they contain a sequence of characters that look like a percent escape
 (e.g. =[0-9A-Fa-f]{2}=) but are in fact not a percent escape.

 The function below can be used to perform a preliminary check for such
 links in an Org mode file.  It will run through all links in the file
 and issue a warning if it finds a percent escape sequence which is not
 in old Org's list of known percent escapes.

 #+begin_src emacs-lisp
   (defun dmaus/org-check-percent-escapes ()
     "*Check buffer for possibly problematic old link escapes."
     (interactive)
     (when (eq major-mode 'org-mode)
       (let ((old-escapes '("%20" "%5B" "%5D" "%E0" "%E2" "%E7" "%E8" "%E9"
                            "%EA" "%EE" "%F4" "%F9" "%FB" "%3B" "%3D" "%2B")))
         (unless (boundp 'warning-suppress-types)
           (setq warning-suppress-types nil))
         (widen)
         (show-all)
         (goto-char (point-min))
         (while (re-search-forward org-any-link-re nil t)
           (let ((end (match-end 0)))
             (goto-char (match-beginning 0))
             (while (re-search-forward "%[0-9a-zA-Z]\\{2\\}" end t)
               (let ((escape (match-string-no-properties 0)))
                 (unless (member (upcase escape) old-escapes)
                   (warn "Found unknown percent escape sequence %s at buffer %s, position %d"
                         escape
                         (buffer-name)
                         (- (point) 3)))))
             (goto-char end))))))
 #+end_src

*** Structure Movement and Editing 
**** Show next/prev heading tidily

 #+index: Navigation!Heading
 - Dan Davison
   These close the current heading and open the next/previous heading.

 #+begin_src emacs-lisp
 (defun ded/org-show-next-heading-tidily ()
   "Show next entry, keeping other entries closed."
   (if (save-excursion (end-of-line) (outline-invisible-p))
       (progn (org-show-entry) (show-children))
     (outline-next-heading)
     (unless (and (bolp) (org-on-heading-p))
       (org-up-heading-safe)
       (hide-subtree)
       (error "Boundary reached"))
     (org-overview)
     (org-reveal t)
     (org-show-entry)
     (show-children)))

 (defun ded/org-show-previous-heading-tidily ()
   "Show previous entry, keeping other entries closed."
   (let ((pos (point)))
     (outline-previous-heading)
     (unless (and (< (point) pos) (bolp) (org-on-heading-p))
       (goto-char pos)
       (hide-subtree)
       (error "Boundary reached"))
     (org-overview)
     (org-reveal t)
     (org-show-entry)
     (show-children)))

 (setq org-use-speed-commands t)
 (add-to-list 'org-speed-commands-user
              '("n" ded/org-show-next-heading-tidily))
 (add-to-list 'org-speed-commands-user
              '("p" ded/org-show-previous-heading-tidily))
 #+end_src

**** Promote all items in subtree
 #+index: Structure Editing!Promote
 - Matt Lundin

 This function will promote all items in a subtree. Since I use
 subtrees primarily to organize projects, the function is somewhat
 unimaginatively called my-org-un-project:

 #+begin_src emacs-lisp
 (defun my-org-un-project ()
   (interactive)
   (org-map-entries 'org-do-promote "LEVEL>1" 'tree)
   (org-cycle t))
 #+end_src

**** Turn a heading into an Org link
     :PROPERTIES:
     :CUSTOM_ID: heading-to-link
     :END:
 #+index: Structure Editing!Heading
 #+index: Link!Turn a heading into a
 From David Maus:

 #+begin_src emacs-lisp
   (defun dmj:turn-headline-into-org-mode-link ()
     "Replace word at point by an Org mode link."
     (interactive)
     (when (org-at-heading-p)
       (let ((hl-text (nth 4 (org-heading-components))))
         (unless (or (null hl-text)
                     (org-string-match-p "^[ \t]*:[^:]+:$" hl-text))
           (beginning-of-line)
           (search-forward hl-text (point-at-eol))
           (replace-string
            hl-text
            (format "[[file:%s.org][%s]]"
                    (org-link-escape hl-text)
                    (org-link-escape hl-text '((?\] . "%5D") (?\[ . "%5B"))))
            nil (- (point) (length hl-text)) (point))))))
 #+end_src

**** Using M-up and M-down to transpose paragraphs
 #+index: Structure Editing!paragraphs

 From Paul Sexton: By default, if used within ordinary paragraphs in
 org mode, =M-up= and =M-down= transpose *lines* (not sentences).  The
 following code makes these keys transpose paragraphs, keeping the
 point at the start of the moved paragraph. Behavior in tables and
 headings is unaffected. It would be easy to modify this to transpose
 sentences.

 #+begin_src emacs-lisp
 (defun org-transpose-paragraphs (arg)
  (interactive)
  (when (and (not (or (org-at-table-p) (org-on-heading-p) (org-at-item-p)))
             (thing-at-point 'sentence))
    (transpose-paragraphs arg)
    (backward-paragraph)
    (re-search-forward "[[:graph:]]")
    (goto-char (match-beginning 0))
    t))

 (add-to-list 'org-metaup-hook 
  (lambda () (interactive) (org-transpose-paragraphs -1)))
 (add-to-list 'org-metadown-hook 
  (lambda () (interactive) (org-transpose-paragraphs 1)))
 #+end_src
**** Changelog support for org headers
 #+index: Structure Editing!Heading
 -- James TD Smith

 Put the following in your =.emacs=, and =C-x 4 a= and other functions which
 use =add-log-current-defun= like =magit-add-log= will pick up the nearest org
 headline as the "current function" if you add a changelog entry from an org
 buffer.

 #+BEGIN_SRC emacs-lisp
   (defun org-log-current-defun ()
     (save-excursion
       (org-back-to-heading)
       (if (looking-at org-complex-heading-regexp)
           (match-string 4))))

   (add-hook 'org-mode-hook
             (lambda ()
               (make-variable-buffer-local 'add-log-current-defun-function)
               (setq add-log-current-defun-function 'org-log-current-defun)))
 #+END_SRC

**** Different org-cycle-level behavior
 #+index: Cycling!behavior
 -- Ryan Thompson

 In recent org versions, when your point (cursor) is at the end of an
 empty header line (like after you first created the header), the TAB
 key (=org-cycle=) has a special behavior: it cycles the headline through
 all possible levels. However, I did not like the way it determined
 "all possible levels," so I rewrote the whole function, along with a
 couple of supporting functions.

 The original function's definition of "all possible levels" was "every
 level from 1 to one more than the initial level of the current
 headline before you started cycling." My new definition is "every
 level from 1 to one more than the previous headline's level." So, if
 you have a headline at level 4 and you use ALT+RET to make a new
 headline below it, it will cycle between levels 1 and 5, inclusive.

 The main advantage of my custom =org-cycle-level= function is that it
 is stateless: the next level in the cycle is determined entirely by
 the contents of the buffer, and not what command you executed last.
 This makes it more predictable, I hope.

 #+BEGIN_SRC emacs-lisp
 (require 'cl)

 (defun org-point-at-end-of-empty-headline ()
   "If point is at the end of an empty headline, return t, else nil."
   (and (looking-at "[ \t]*$")
	(save-excursion
          (beginning-of-line 1)
          (looking-at (concat "^\\(\\*+\\)[ \t]+\\(" org-todo-regexp "\\)?[ \t]*")))))

 (defun org-level-increment ()
   "Return the number of stars that will be added or removed at a
 time to headlines when structure editing, based on the value of
 `org-odd-levels-only'."
   (if org-odd-levels-only 2 1))

 (defvar org-previous-line-level-cached nil)

 (defun org-recalculate-previous-line-level ()
   "Same as `org-get-previous-line-level', but does not use cached
 value. It does *set* the cached value, though."
   (set 'org-previous-line-level-cached
	(let ((current-level (org-current-level))
              (prev-level (when (> (line-number-at-pos) 1)
                            (save-excursion
                              (previous-line)
                              (org-current-level)))))
          (cond ((null current-level) nil) ; Before first headline
		((null prev-level) 0)      ; At first headline
		(prev-level)))))

 (defun org-get-previous-line-level ()
   "Return the outline depth of the last headline before the
 current line. Returns 0 for the first headline in the buffer, and
 nil if before the first headline."
   ;; This calculation is quite expensive, with all the regex searching
   ;; and stuff. Since org-cycle-level won't change lines, we can reuse
   ;; the last value of this command.
   (or (and (eq last-command 'org-cycle-level)
            org-previous-line-level-cached)
       (org-recalculate-previous-line-level)))

 (defun org-cycle-level ()
   (interactive)
   (let ((org-adapt-indentation nil))
     (when (org-point-at-end-of-empty-headline)
       (setq this-command 'org-cycle-level) ;Only needed for caching
       (let ((cur-level (org-current-level))
             (prev-level (org-get-previous-line-level)))
         (cond
          ;; If first headline in file, promote to top-level.
          ((= prev-level 0)
           (loop repeat (/ (- cur-level 1) (org-level-increment))
                 do (org-do-promote)))
          ;; If same level as prev, demote one.
          ((= prev-level cur-level)
           (org-do-demote))
          ;; If parent is top-level, promote to top level if not already.
          ((= prev-level 1)
           (loop repeat (/ (- cur-level 1) (org-level-increment))
                 do (org-do-promote)))
          ;; If top-level, return to prev-level.
          ((= cur-level 1)
           (loop repeat (/ (- prev-level 1) (org-level-increment))
                 do (org-do-demote)))
          ;; If less than prev-level, promote one.
          ((< cur-level prev-level)
           (org-do-promote))
          ;; If deeper than prev-level, promote until higher than
          ;; prev-level.
          ((> cur-level prev-level)
           (loop repeat (+ 1 (/ (- cur-level prev-level) (org-level-increment)))
                 do (org-do-promote))))
         t))))
 #+END_SRC

**** Count words in an Org buffer
 #FIXME: Does not fit too well under Structure. Any idea where to put it?
 Paul Sexton [[http://article.gmane.org/gmane.emacs.orgmode/38014][posted]] this function to count words in an Org buffer:

 #+begin_src emacs-lisp
 (defun org-word-count (beg end
                            &optional count-latex-macro-args?
                            count-footnotes?)
   "Report the number of words in the Org mode buffer or selected region.
 Ignores:
 - comments
 - tables
 - source code blocks (#+BEGIN_SRC ... #+END_SRC, and inline blocks)
 - hyperlinks (but does count words in hyperlink descriptions)
 - tags, priorities, and TODO keywords in headers
 - sections tagged as 'not for export'.

 The text of footnote definitions is ignored, unless the optional argument
 COUNT-FOOTNOTES? is non-nil.

 If the optional argument COUNT-LATEX-MACRO-ARGS? is non-nil, the word count
 includes LaTeX macro arguments (the material between {curly braces}).
 Otherwise, and by default, every LaTeX macro counts as 1 word regardless
 of its arguments."
   (interactive "r")
   (unless mark-active
     (setf beg (point-min)
	   end (point-max)))
   (let ((wc 0)
	 (latex-macro-regexp "\\\\[A-Za-z]+\\(\\[[^]]*\\]\\|\\){\\([^}]*\\)}"))
     (save-excursion
       (goto-char beg)
       (while (< (point) end)
         (cond
          ;; Ignore comments.
          ((or (org-in-commented-line) (org-at-table-p))
           nil)
          ;; Ignore hyperlinks. But if link has a description, count
          ;; the words within the description.
          ((looking-at org-bracket-link-analytic-regexp)
           (when (match-string-no-properties 5)
             (let ((desc (match-string-no-properties 5)))
               (save-match-data
                 (incf wc (length (remove "" (org-split-string
                                              desc "\\W")))))))
           (goto-char (match-end 0)))
          ((looking-at org-any-link-re)
           (goto-char (match-end 0)))
          ;; Ignore source code blocks.
          ((org-in-regexps-block-p "^#\\+BEGIN_SRC\\W" "^#\\+END_SRC\\W")
           nil)
          ;; Ignore inline source blocks, counting them as 1 word.
          ((save-excursion
             (backward-char)
             (looking-at org-babel-inline-src-block-regexp))
           (goto-char (match-end 0))
           (setf wc (+ 2 wc)))
          ;; Count latex macros as 1 word, ignoring their arguments.
          ((save-excursion
             (backward-char)
             (looking-at latex-macro-regexp))
           (goto-char (if count-latex-macro-args?
                          (match-beginning 2)
			(match-end 0)))
           (setf wc (+ 2 wc)))
          ;; Ignore footnotes.
          ((and (not count-footnotes?)
		(or (org-footnote-at-definition-p)
                    (org-footnote-at-reference-p)))
           nil)
          (t
           (let ((contexts (org-context)))
             (cond
              ;; Ignore tags and TODO keywords, etc.
              ((or (assoc :todo-keyword contexts)
                   (assoc :priority contexts)
                   (assoc :keyword contexts)
                   (assoc :checkbox contexts))
               nil)
              ;; Ignore sections marked with tags that are
              ;; excluded from export.
              ((assoc :tags contexts)
               (if (intersection (org-get-tags-at) org-export-exclude-tags
                                 :test 'equal)
                   (org-forward-same-level 1)
                 nil))
              (t
               (incf wc))))))
         (re-search-forward "\\w+\\W*")))
     (message (format "%d words in %s." wc
                      (if mark-active "region" "buffer")))))
 #+end_src

**** Check for misplaced SCHEDULED and DEADLINE cookies

 The =SCHEDULED= and =DEADLINE= cookies should be used on the line *right
 below* the headline -- like this:

 #+begin_src org
   ,* A headline
   ,  SCHEDULED: <2012-04-09 lun.>
 #+end_src

 This is what =org-scheduled= and =org-deadline= (and other similar
 commands) do.  And the manual explicitely tell people to stick to this
 format (see the section "8.3.1 Inserting deadlines or schedules").

 If you think you might have subtrees with misplaced =SCHEDULED= and
 =DEADLINE= cookies, this command lets you check the current buffer:

 #+begin_src emacs-lisp
 (defun org-check-misformatted-subtree ()
   "Check misformatted entries in the current buffer."
   (interactive)
   (show-all)
   (org-map-entries
    (lambda ()
      (when (and (move-beginning-of-line 2)
		 (not (looking-at org-heading-regexp)))
	(if (or (and (org-get-scheduled-time (point))
		     (not (looking-at (concat "^.*" org-scheduled-regexp))))
		(and (org-get-deadline-time (point))
		     (not (looking-at (concat "^.*" org-deadline-regexp)))))
	    (when (y-or-n-p "Fix this subtree? ")
	      (message "Call the function again when you're done fixing this subtree.")
	      (recursive-edit))
	  (message "All subtrees checked."))))))
 #+end_src

**** Sorting list by checkbox type

 #+index: checkbox!sorting

 You can use a custom function to sort list by checkbox type.
 Here is a function suggested by Carsten:

 #+BEGIN_SRC emacs-lisp
 (defun org-sort-list-by-checkbox-type ()
   "Sort list items according to Checkbox state."
   (interactive)
   (org-sort-list
    nil ?f
    (lambda ()
      (if (looking-at org-list-full-item-re)
	  (cdr (assoc (match-string 3)
		      '(("[X]" . 1) ("[-]" . 2) ("[ ]" . 3) (nil . 4))))
	4))))
 #+END_SRC

 Use the function above directly on the list.  If you want to use an
 equivalent function after =C-c ^ f=, use this one instead:

 #+BEGIN_SRC emacs-lisp
   (defun org-sort-list-by-checkbox-type-1 ()
     (lambda ()
       (if (looking-at org-list-full-item-re)
           (cdr (assoc (match-string 3)
                       '(("[X]" . 1) ("[-]" . 2) ("[ ]" . 3) (nil . 4))))
         4)))
 #+END_SRC

*** Org Table
**** Align all tables in a file

 Andrew Young provided this function in [[http://thread.gmane.org/gmane.emacs.orgmode/58974/focus%3D58976][this thread]]:

 #+begin_src emacs-lisp
   (defun my-align-all-tables ()
     (interactive)
     (org-table-map-tables 'org-table-align 'quietly))
 #+end_src

**** Transpose table
 #+index: Table!Calculation
     :PROPERTIES:
     :CUSTOM_ID: transpose-table
     :END:

 Since Org 7.8, you can use =org-table-transpose-table-at-point= (which
 see.)  There are also other solutions:

 - with org-babel and Emacs Lisp: provided by Thomas S. Dye in the mailing
   list, see [[http://thread.gmane.org/gmane.emacs.orgmode/23809/focus=23815][gmane]] or [[http://lists.gnu.org/archive/html/emacs-orgmode/2010-04/msg00239.html][gnu]]

 - with org-babel and R: provided by Dan Davison in the mailing list (old
   =#+TBLR:= syntax), see [[http://thread.gmane.org/gmane.emacs.orgmode/10159/focus=10159][gmane]] or [[http://lists.gnu.org/archive/html/emacs-orgmode/2008-12/msg00454.html][gnu]]

 - with field coordinates in formulas (=@#= and =$#=): see [[file:org-hacks.org::#field-coordinates-in-formulas-transpose-table][Worg]].

**** Manipulate hours/minutes/seconds in table formulas
 #+index: Table!hours-minutes-seconds
 Both Bastien and Martin Halder have posted code ([[http://article.gmane.org/gmane.emacs.orgmode/39519][Bastien's code]] and
 [[http://article.gmane.org/gmane.emacs.orgmode/39519][Martin's code]]) for interpreting =dd:dd= or =dd:dd:dd= strings (where
 "=d=" is any digit) as time values in Org-mode table formula.  These
 functions have now been wrapped up into a =with-time= macro which can
 be used in table formula to translate table cell values to and from
 numerical values for algebraic manipulation.

 Here is the code implementing this macro.
 #+begin_src emacs-lisp :results silent
   (defun org-time-string-to-seconds (s)
     "Convert a string HH:MM:SS to a number of seconds."
     (cond
      ((and (stringp s)
            (string-match "\\([0-9]+\\):\\([0-9]+\\):\\([0-9]+\\)" s))
       (let ((hour (string-to-number (match-string 1 s)))
             (min (string-to-number (match-string 2 s)))
             (sec (string-to-number (match-string 3 s))))
         (+ (* hour 3600) (* min 60) sec)))
      ((and (stringp s)
            (string-match "\\([0-9]+\\):\\([0-9]+\\)" s))
       (let ((min (string-to-number (match-string 1 s)))
             (sec (string-to-number (match-string 2 s))))
         (+ (* min 60) sec)))
      ((stringp s) (string-to-number s))
      (t s)))

   (defun org-time-seconds-to-string (secs)
     "Convert a number of seconds to a time string."
     (cond ((>= secs 3600) (format-seconds "%h:%.2m:%.2s" secs))
           ((>= secs 60) (format-seconds "%m:%.2s" secs))
           (t (format-seconds "%s" secs))))

   (defmacro with-time (time-output-p &rest exprs)
     "Evaluate an org-table formula, converting all fields that look
   like time data to integer seconds.  If TIME-OUTPUT-P then return
   the result as a time value."
     (list
      (if time-output-p 'org-time-seconds-to-string 'identity)
      (cons 'progn
            (mapcar
             (lambda (expr)
               `,(cons (car expr)
                       (mapcar
			(lambda (el)
                          (if (listp el)
                              (list 'with-time nil el)
                            (org-time-string-to-seconds el)))
			(cdr expr))))
             `,@exprs))))
 #+end_src

 Which allows the following forms of table manipulation such as adding
 and subtracting time values.
 : | Date             | Start | Lunch |  Back |   End |  Sum |
 : |------------------+-------+-------+-------+-------+------|
 : | [2011-03-01 Tue] |  8:00 | 12:00 | 12:30 | 18:15 | 9:45 |
 : #+TBLFM: $6='(with-time t (+ (- $5 $4) (- $3 $2)))

 and dividing time values by integers
 : |  time | miles | minutes/mile |
 : |-------+-------+--------------|
 : | 34:43 |   2.9 |        11:58 |
 : | 32:15 |  2.77 |        11:38 |
 : | 33:56 |   3.0 |        11:18 |
 : | 52:22 |  4.62 |        11:20 |
 : #+TBLFM: $3='(with-time t (/ $1 $2))

 *Update*: As of Org version 7.6, you can use the =T= flag (both in Calc and
 Elisp formulas) to compute time durations.  For example:

 : | Task 1 | Task 2 |   Total |
 : |--------+--------+---------|
 : |  35:00 |  35:00 | 1:10:00 |
 : #+TBLFM: @2$3=$1+$2;T

**** Dates computation
 #+index: Table!dates
 Xin Shi [[http://article.gmane.org/gmane.emacs.orgmode/15692][asked]] for a way to calculate the duration of 
 dates stored in an org table.

 Nick Dokos [[http://article.gmane.org/gmane.emacs.orgmode/15694][suggested]]:

 Try the following:

 : | Start Date |   End Date | Duration |
 : |------------+------------+----------|
 : | 2004.08.07 | 2005.07.08 |      335 |
 : #+TBLFM: $3=(date(<$2>)-date(<$1>))

 See [[http://thread.gmane.org/gmane.emacs.orgmode/7741][this thread]] as well as [[http://article.gmane.org/gmane.emacs.orgmode/7753][this post]] (which is really a followup on the
 above).  The problem that this last article pointed out was solved in [[http://article.gmane.org/gmane.emacs.orgmode/8001][this
 post]] and Chris Randle's original musings are [[http://article.gmane.org/gmane.emacs.orgmode/6536/][here]].

**** Hex computation
 #+index: Table!Calculation
 As with Times computation, the following code allows Computation with
 Hex values in Org-mode tables using the =with-hex= macro.

 Here is the code implementing this macro.
 #+begin_src emacs-lisp
   (defun org-hex-strip-lead (str)
     (if (and (> (length str) 2) (string= (substring str 0 2) "0x"))
         (substring str 2) str))

   (defun org-hex-to-hex (int)
     (format "0x%x" int))

   (defun org-hex-to-dec (str)
     (cond
      ((and (stringp str)
            (string-match "\\([0-9a-f]+\\)" (setf str (org-hex-strip-lead str))))
       (let ((out 0))
         (mapc
          (lambda (ch)
            (setf out (+ (* out 16)
                         (if (and (>= ch 48) (<= ch 57)) (- ch 48) (- ch 87)))))
          (coerce (match-string 1 str) 'list))
         out))
      ((stringp str) (string-to-number str))
      (t str)))

   (defmacro with-hex (hex-output-p &rest exprs)
     "Evaluate an org-table formula, converting all fields that look
       like hexadecimal to decimal integers.  If HEX-OUTPUT-P then
       return the result as a hex value."
     (list
      (if hex-output-p 'org-hex-to-hex 'identity)
      (cons 'progn
            (mapcar
             (lambda (expr)
               `,(cons (car expr)
                       (mapcar (lambda (el)
                                 (if (listp el)
                                     (list 'with-hex nil el)
                                   (org-hex-to-dec el)))
                               (cdr expr))))
             `,@exprs))))
 #+end_src

 Which allows the following forms of table manipulation such as adding
 and subtracting hex values.
 | 0x10 | 0x0 | 0x10 |  16 |
 | 0x20 | 0x1 | 0x21 |  33 |
 | 0x30 | 0x2 | 0x32 |  50 |
 | 0xf0 | 0xf | 0xff | 255 |
 #+TBLFM: $3='(with-hex 'hex (+ $2 $1))::$4='(with-hex nil (identity $3))

**** Field coordinates in formulas (=@#= and =$#=)
     :PROPERTIES:
     :CUSTOM_ID: field-coordinates-in-formulas
     :END:
 #+index: Table!Field Coordinates
 -- Michael Brand

 Following are some use cases that can be implemented with the “field
 coordinates in formulas” described in the corresponding chapter in the
 [[http://orgmode.org/manual/References.html#References][Org manual]].

***** Copy a column from a remote table into a column
      :PROPERTIES:
      :CUSTOM_ID: field-coordinates-in-formulas-copy-col-to-col
      :END:

 current column =$3= = remote column =$2=:
 : #+TBLFM: $3 = remote(FOO, @@#$2)

***** Copy a row from a remote table transposed into a column
      :PROPERTIES:
      :CUSTOM_ID: field-coordinates-in-formulas-copy-row-to-col
      :END:

 current column =$1= = transposed remote row =@1=:
 : #+TBLFM: $1 = remote(FOO, @$#$@#)

***** Transpose table
      :PROPERTIES:
      :CUSTOM_ID: field-coordinates-in-formulas-transpose-table
      :END:

 -- Michael Brand

 This is more like a demonstration of using “field coordinates in formulas”
 and is bound to be slow for large tables. See the discussion in the mailing
 list on
 [[http://thread.gmane.org/gmane.emacs.orgmode/22610/focus=23662][gmane]] or
 [[http://lists.gnu.org/archive/html/emacs-orgmode/2010-04/msg00086.html][gnu]].
 For more efficient solutions see
 [[file:org-hacks.org::#transpose-table][Worg]].

 To transpose this 4x7 table

 : #+TBLNAME: FOO
 : | year | 2004 | 2005 | 2006 | 2007 | 2008 | 2009 |
 : |------+------+------+------+------+------+------|
 : | min  |  401 |  501 |  601 |  701 |  801 |  901 |
 : | avg  |  402 |  502 |  602 |  702 |  802 |  902 |
 : | max  |  403 |  503 |  603 |  703 |  803 |  903 |

 start with a 7x4 table without any horizontal line (to have filled
 also the column header) and yet empty:

 : |   |   |   |   |
 : |   |   |   |   |
 : |   |   |   |   |
 : |   |   |   |   |
 : |   |   |   |   |
 : |   |   |   |   |
 : |   |   |   |   |

 Then add the =TBLFM= line below.  After recalculation this will end up with
 the transposed copy:

 : | year | min | avg | max |
 : | 2004 | 401 | 402 | 403 |
 : | 2005 | 501 | 502 | 503 |
 : | 2006 | 601 | 602 | 603 |
 : | 2007 | 701 | 702 | 703 |
 : | 2008 | 801 | 802 | 803 |
 : | 2009 | 901 | 902 | 903 |
 : #+TBLFM: @<$<..@>$> = remote(FOO, @$#$@#)

 The formula simply exchanges row and column numbers by taking
 - the absolute remote row number =@$#= from the current column number =$#=
 - the absolute remote column number =$@#= from the current row number =@#=

 Formulas to be taken over from the remote table will have to be transformed
 manually.

***** Dynamic variation of ranges

 -- Michael Brand

 In this example all columns next to =quote= are calculated from the column
 =quote= and show the average change of the time series =quote[year]=
 during the period of the preceding =1=, =2=, =3= or =4= years:

 : | year | quote |   1 a |   2 a |   3 a |   4 a |
 : |------+-------+-------+-------+-------+-------|
 : | 2005 |    10 |       |       |       |       |
 : | 2006 |    12 | 0.200 |       |       |       |
 : | 2007 |    14 | 0.167 | 0.183 |       |       |
 : | 2008 |    16 | 0.143 | 0.155 | 0.170 |       |
 : | 2009 |    18 | 0.125 | 0.134 | 0.145 | 0.158 |
 : #+TBLFM: @I$3..@>$>=if(@# >= $#, ($2 / subscr(@-I$2..@+I$2, @# + 1 - $#)) ^ (1 / ($# - 2)) - 1, string("")) +.0; f-3

 The important part of the formula without the field blanking is:

 : ($2 / subscr(@-I$2..@+I$2, @# + 1 - $#)) ^ (1 / ($# - 2)) - 1

 which is the Emacs Calc implementation of the equation

 /AvgChange(i, a) = (quote[i] / quote[i - a]) ^ (1 / a) - 1/

 where /i/ is the current time and /a/ is the length of the preceding period.

**** Change the column sequence in one row only
 #+index: Table!Editing
     :PROPERTIES:
     :CUSTOM_ID: column-sequence-in-row
     :END:

 -- Michael Brand

 The functions below can be used to change the column sequence in one row
 only, without affecting the other rows above and below like with M-<left> or
 M-<right> (org-table-move-column). Please see the docstring of the functions
 for more explanations. Below is one example per function, with this original
 table as the starting point for each example:
 : | a | b | c  | d  |
 : | e | 9 | 10 | 11 |
 : | f | g | h  | i  |

***** Move in row left

 1) place point at "10" in original table
 2) result of M-x my-org-table-move-column-in-row-left:
    : | a | b  | c | d  |
    : | e | 10 | 9 | 11 |
    : | f | g  | h | i  |

***** Move in row right

 1) place point at "9" in original table
 2) result of M-x my-org-table-move-column-in-row-right:
    : | a | b  | c | d  |
    : | e | 10 | 9 | 11 |
    : | f | g  | h | i  |

***** Rotate in row left

 1) place point at "9" in original table
 2) result of M-x my-org-table-rotate-column-in-row-left:
    : | a | b  | c  | d |
    : | e | 10 | 11 | 9 |
    : | f | g  | h  | i |

***** Rotate in row right

 1) place point at "9" in original table
 2) result of M-x my-org-table-rotate-column-in-row-right:
    : | a | b  | c | d  |
    : | e | 11 | 9 | 10 |
    : | f | g  | h | i  |

***** The functions

 #+BEGIN_SRC emacs-lisp
 (defun my-org-table-move-column-in-row-right ()
   "Move column to the right, limited to the current row."
   (interactive)
   (my-org-table-move-column-in-row nil))
 (defun my-org-table-move-column-in-row-left ()
   "Move column to the left, limited to the current row."
   (interactive)
   (my-org-table-move-column-in-row 'left))

 (defun my-org-table-move-column-in-row (&optional left)
   "Move the current column to the right, limited to the current row.
 With arg LEFT, move to the left.  For repeated invocation the point follows
 the value and changes to the target colum.  Does not fix formulas."
   ;; derived from `org-table-move-column'
   (interactive "P")
   (if (not (org-at-table-p))
       (error "Not at a table"))
   (org-table-find-dataline)
   (org-table-check-inside-data-field)
   (let* ((col (org-table-current-column))
          (col1 (if left (1- col) col))
          ;; Current cursor position
          (colpos (if left (1- col) (1+ col))))
     (if (and left (= col 1))
         (error "Cannot move column further left"))
     (if (and (not left) (looking-at "[^|\n]*|[^|\n]*$"))
         (error "Cannot move column further right"))
     (org-table-goto-column col1 t)
     (and (looking-at "|\\([^|\n]+\\)|\\([^|\n]+\\)|")
          (replace-match "|\\2|\\1|"))
     (org-table-goto-column colpos)
     (org-table-align)))

 (defun my-org-table-rotate-column-in-row-right ()
   "Rotate column to the right, limited to the current row."
   (interactive)
   (my-org-table-rotate-column-in-row nil))
 (defun my-org-table-rotate-column-in-row-left ()
   "Rotate column to the left, limited to the current row."
   (interactive)
   (my-org-table-rotate-column-in-row 'left))

 (defun my-org-table-rotate-column-in-row (&optional left)
   "Rotate the current column to the right, limited to the current row.
 With arg LEFT, rotate to the left.  The boundaries of the rotation range are
 the current and the most right column for both directions.  For repeated
 invocation the point stays on the current column.  Does not fix formulas."
   ;; derived from `org-table-move-column'
   (interactive "P")
   (if (not (org-at-table-p))
       (error "Not at a table"))
   (org-table-find-dataline)
   (org-table-check-inside-data-field)
   (let ((col (org-table-current-column)))
     (org-table-goto-column col t)
     (and (looking-at (if left
                          "|\\([^|\n]+\\)|\\([^\n]+\\)|$"
			"|\\([^\n]+\\)|\\([^|\n]+\\)|$"))
          (replace-match "|\\2|\\1|"))
     (org-table-goto-column col)
     (org-table-align)))
 #+END_SRC

***** Key bindings

 As hack I have this in an Org buffer to change temporarily to the desired
 behavior with C-c C-c on one of the three snippets:
 : - move in row:
 :   #+begin_src emacs-lisp :results silent
 :     (org-defkey org-mode-map [(meta left)]
 :                 'my-org-table-move-column-in-row-left)
 :     (org-defkey org-mode-map [(meta right)]
 :                 'my-org-table-move-column-in-row-right)
 :     (org-defkey org-mode-map [(left)]  'org-table-previous-field)
 :     (org-defkey org-mode-map [(right)] 'org-table-next-field)
 :   #+end_src
 :
 : - rotate in row:
 :   #+begin_src emacs-lisp :results silent
 :     (org-defkey org-mode-map [(meta left)]
 :                 'my-org-table-rotate-column-in-row-left)
 :     (org-defkey org-mode-map [(meta right)]
 :                 'my-org-table-rotate-column-in-row-right)
 :     (org-defkey org-mode-map [(left)]  'org-table-previous-field)
 :     (org-defkey org-mode-map [(right)] 'org-table-next-field)
 :   #+end_src
 :
 : - back to original:
 :   #+begin_src emacs-lisp :results silent
 :     (org-defkey org-mode-map [(meta left)]  'org-metaleft)
 :     (org-defkey org-mode-map [(meta right)] 'org-metaright)
 :     (org-defkey org-mode-map [(left)]  'backward-char)
 :     (org-defkey org-mode-map [(right)] 'forward-char)
 :   #+end_src

***** reasons why this is not put into the Org core

 I consider this as only a hack for several reasons:
 - Generalization:  The existing org-table-move-column function could be
   enhanced with additional optional parameters to incorporate these
   functionalities and could be used as the only function for better
   maintainability.  Now it's only a copy/paste hack of several similar
   functions with simple modifications.
 - Bindings:  Should be convenient for repetition like M-<right>.  What
   should be bound where, what has to be left unbound?
 - Does not fix formulas.  Could be resolved for field formulas but
   most probably not for column or range formulas and this can lead
   to confusion.  AFAIK all "official" table manipulations fix formulas.
 - Completeness:  Not all variations and combinations are covered yet
   - left-right, up-down
   - move, rotate with range to end, rotate with range to begin
   - whole column/row, only in-row/in-column

*** Capture and Remember
**** Customize the size of the frame for remember
 #+index: Remember!frame
 #+index: Customization!remember
 (Note: this hack is likely out of date due to the development of
 org-capture.)

 #FIXME: gmane link?
 On emacs-orgmode, Ryan C. Thompson suggested this:

 #+begin_quote
 I am using org-remember set to open a new frame when used,
 and the default frame size is much too large. To fix this, I have
 designed some advice and a custom variable to implement custom
 parameters for the remember frame:
 #+end_quote

 #+begin_src emacs-lisp
 (defcustom remember-frame-alist nil
   "Additional frame parameters for dedicated remember frame."
   :type 'alist
   :group 'remember)

 (defadvice remember (around remember-frame-parameters activate)
   "Set some frame parameters for the remember frame."
   (let ((default-frame-alist (append remember-frame-alist
                                      default-frame-alist)))
     ad-do-it))
 #+end_src

 Setting remember-frame-alist to =((width . 80) (height . 15)))= give a
 reasonable size for the frame.
*** Handling Links
**** [[#heading-to-link][Turn a heading into an org link]] 
**** Quickaccess to the link part of hyperlinks
 #+index: Link!Referent
 Christian Moe [[http://permalink.gmane.org/gmane.emacs.orgmode/43122][asked]], if there is a simpler way to copy the link part
 of an org hyperling other than to use `C-c C-l C-a C-k C-g', 
 which is indeed kind of cumbersome.

 The thread offered [[http://permalink.gmane.org/gmane.emacs.orgmode/43606][two ways]]:

 Using a [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Keyboard-Macros.html][keyboard macro]]:
 #+begin_src emacs-lisp
 (fset 'getlink
       (lambda (&optional arg) 
         "Keyboard macro." 
         (interactive "p") 
         (kmacro-exec-ring-item (quote ("\C-c\C-l\C-a\C-k\C-g" 0 "%d")) arg)))
 #+end_src

 or a function: 
 #+begin_src emacs-lisp
 (defun my-org-extract-link ()
   "Extract the link location at point and put it on the killring."
   (interactive)
   (when (org-in-regexp org-bracket-link-regexp 1)
     (kill-new (org-link-unescape (org-match-string-no-properties 1)))))
 #+end_src

 They put the link destination on the killring and can be easily bound to a key.

**** Insert link with HTML title as default description
 When using `org-insert-link' (`C-c C-l') it might be useful to extract contents
 from HTML <title> tag and use it as a default link description. Here is a way to
 accomplish this:

 #+begin_src emacs-lisp
 (require 'mm-url) ; to include mm-url-decode-entities-string

 (defun my-org-insert-link ()
   "Insert org link where default description is set to html title."
   (interactive)
   (let* ((url (read-string "URL: "))
          (title (get-html-title-from-url url)))
     (org-insert-link nil url title)))

 (defun get-html-title-from-url (url)
   "Return content in <title> tag."
   (let (x1 x2 (download-buffer (url-retrieve-synchronously url)))
     (save-excursion
       (set-buffer download-buffer)
       (beginning-of-buffer)
       (setq x1 (search-forward "<title>"))
       (search-forward "</title>")
       (setq x2 (search-backward "<"))
       (mm-url-decode-entities-string (buffer-substring-no-properties x1 x2)))))
 #+end_src

 Then just use `M-x my-org-insert-link' instead of `org-insert-link'.

*** Archiving Content in Org-Mode
**** Preserve top level headings when archiving to a file
 #+index: Archiving!Preserve top level headings
 - Matt Lundin

 To preserve (somewhat) the integrity of your archive structure while
 archiving lower level items to a file, you can use the following
 defadvice:

 #+begin_src emacs-lisp
 (defadvice org-archive-subtree (around my-org-archive-subtree activate)
   (let ((org-archive-location
          (if (save-excursion (org-back-to-heading)
                              (> (org-outline-level) 1))
              (concat (car (split-string org-archive-location "::"))
                      "::* "
                      (car (org-get-outline-path)))
            org-archive-location)))
     ad-do-it))
 #+end_src

 Thus, if you have an outline structure such as...

 #+begin_src org
 ,* Heading
 ,** Subheading
 ,*** Subsubheading
 #+end_src

 ...archiving "Subsubheading" to a new file will set the location in
 the new file to the top level heading:

 #+begin_src org
 ,* Heading
 ,** Subsubheading
 #+end_src

 While this hack obviously destroys the outline hierarchy somewhat, it
 at least preserves the logic of level one groupings.

 A slightly more complex version of this hack will not only keep the
 archive organized by top-level headings, but will also preserve the
 tags found on those headings:

 #+begin_src emacs-lisp
   (defun my-org-inherited-no-file-tags ()
     (let ((tags (org-entry-get nil "ALLTAGS" 'selective))
           (ltags (org-entry-get nil "TAGS")))
       (mapc (lambda (tag)
               (setq tags
                     (replace-regexp-in-string (concat tag ":") "" tags)))
             (append org-file-tags (when ltags (split-string ltags ":" t))))
       (if (string= ":" tags) nil tags)))

   (defadvice org-archive-subtree (around my-org-archive-subtree-low-level activate)
     (let ((tags (my-org-inherited-no-file-tags))
           (org-archive-location
            (if (save-excursion (org-back-to-heading)
				(> (org-outline-level) 1))
		(concat (car (split-string org-archive-location "::"))
			"::* "
			(car (org-get-outline-path)))
              org-archive-location)))
       ad-do-it
       (with-current-buffer (find-file-noselect (org-extract-archive-file))
         (save-excursion
           (while (org-up-heading-safe))
           (org-set-tags-to tags)))))
 #+end_src

**** Archive in a date tree
 #+index: Archiving!date tree
 Posted to Org-mode mailing list by Osamu Okano [2010-04-21 Wed].

 (Make sure org-datetree.el is loaded for this to work.)

 #+begin_src emacs-lisp
 ;; (setq org-archive-location "%s_archive::date-tree")
 (defadvice org-archive-subtree
   (around org-archive-subtree-to-data-tree activate)
   "org-archive-subtree to date-tree"
   (if
       (string= "date-tree"
		(org-extract-archive-heading
                 (org-get-local-archive-location)))
       (let* ((dct (decode-time (org-current-time)))
              (y (nth 5 dct))
              (m (nth 4 dct))
              (d (nth 3 dct))
              (this-buffer (current-buffer))
              (location (org-get-local-archive-location))
              (afile (org-extract-archive-file location))
              (org-archive-location
               (format "%s::*** %04d-%02d-%02d %s" afile y m d
                       (format-time-string "%A" (encode-time 0 0 0 d m y)))))
         (message "afile=%s" afile)
         (unless afile
           (error "Invalid `org-archive-location'"))
         (save-excursion
           (switch-to-buffer (find-file-noselect afile))
           (org-datetree-find-year-create y)
           (org-datetree-find-month-create y m)
           (org-datetree-find-day-create y m d)
           (widen)
           (switch-to-buffer this-buffer))
         ad-do-it)
     ad-do-it))
 #+end_src

**** Add inherited tags to archived entries
 #+index: Archiving!Add inherited tags
 To make =org-archive-subtree= keep inherited tags, Osamu OKANO suggests to
 advise the function like this:

 #+begin_example
 (defadvice org-archive-subtree
   (before add-inherited-tags-before-org-archive-subtree activate)
     "add inherited tags before org-archive-subtree"
     (org-set-tags-to (org-get-tags-at)))
 #+end_example

*** Using and Managing Org-Metadata
**** Remove redundant tags of headlines
 #+index: Tag!Remove redundant
 -- David Maus

 A small function that processes all headlines in current buffer and
 removes tags that are local to a headline and inherited by a parent
 headline or the #+FILETAGS: statement.

 #+BEGIN_SRC emacs-lisp
   (defun dmj/org-remove-redundant-tags ()
     "Remove redundant tags of headlines in current buffer.

   A tag is considered redundant if it is local to a headline and
   inherited by a parent headline."
     (interactive)
     (when (eq major-mode 'org-mode)
       (save-excursion
         (org-map-entries
          '(lambda ()
             (let ((alltags (split-string (or (org-entry-get (point) "ALLTAGS") "") ":"))
                   local inherited tag)
               (dolist (tag alltags)
                 (if (get-text-property 0 'inherited tag)
                     (push tag inherited) (push tag local)))
               (dolist (tag local)
                 (if (member tag inherited) (org-toggle-tag tag 'off)))))
          t nil))))
 #+END_SRC

**** Remove empty property drawers
 #+index: Drawer!Empty
 David Maus proposed this:

 #+begin_src emacs-lisp
 (defun dmj:org:remove-empty-propert-drawers ()
   "*Remove all empty property drawers in current file."
   (interactive)
   (unless (eq major-mode 'org-mode)
     (error "You need to turn on Org mode for this function."))
   (save-excursion
     (goto-char (point-min))
     (while (re-search-forward ":PROPERTIES:" nil t)
       (save-excursion
	 (org-remove-empty-drawer-at "PROPERTIES" (match-beginning 0))))))
 #+end_src

**** Group task list by a property
 #+index: Agenda!Group task list
 This advice allows you to group a task list in Org-Mode.  To use it,
 set the variable =org-agenda-group-by-property= to the name of a
 property in the option list for a TODO or TAGS search.  The resulting
 agenda view will group tasks by that property prior to searching.

 #+begin_src emacs-lisp
 (defvar org-agenda-group-by-property nil
   "Set this in org-mode agenda views to group tasks by property")

 (defun org-group-bucket-items (prop items)
   (let ((buckets ()))
     (dolist (item items)
       (let* ((marker (get-text-property 0 'org-marker item))
              (pvalue (org-entry-get marker prop t))
              (cell (assoc pvalue buckets)))
         (if cell
             (setcdr cell (cons item (cdr cell)))
           (setq buckets (cons (cons pvalue (list item))
                               buckets)))))
     (setq buckets (mapcar (lambda (bucket)
                             (cons (car bucket)
                                   (reverse (cdr bucket))))
                           buckets))
     (sort buckets (lambda (i1 i2)
                     (string< (car i1) (car i2))))))

 (defadvice org-finalize-agenda-entries (around org-group-agenda-finalize
						(list &optional nosort))
   "Prepare bucketed agenda entry lists"
   (if org-agenda-group-by-property
       ;; bucketed, handle appropriately
       (let ((text ""))
         (dolist (bucket (org-group-bucket-items
                          org-agenda-group-by-property
                          list))
           (let ((header (concat "Property "
                                 org-agenda-group-by-property
                                 " is "
                                 (or (car bucket) "<nil>") ":\n")))
             (add-text-properties 0 (1- (length header))
                                  (list 'face 'org-agenda-structure)
                                  header)
             (setq text
                   (concat text header
                           ;; recursively process
                           (let ((org-agenda-group-by-property nil))
                             (org-finalize-agenda-entries
                              (cdr bucket) nosort))
                           "\n\n"))))
         (setq ad-return-value text))
     ad-do-it))
 (ad-activate 'org-finalize-agenda-entries)
 #+end_src
**** A way to tag a task so that when clocking-out user is prompted to take a note.
 #+index: Tag!Clock
 #+index: Clock!Tag
     Thanks to Richard Riley (see [[http://permalink.gmane.org/gmane.emacs.orgmode/40896][this post on the mailing list]]).

 A small hook run when clocking out of a task that prompts for a note
 when the tag "=clockout_note=" is found in a headline. It uses the tag
 ("=clockout_note=") so inheritance can also be used...

 #+begin_src emacs-lisp
   (defun rgr/check-for-clock-out-note()
         (interactive)
         (save-excursion
           (org-back-to-heading)
           (let ((tags (org-get-tags)))
             (and tags (message "tags: %s " tags)
                  (when (member "clocknote" tags)
                    (org-add-note))))))

   (add-hook 'org-clock-out-hook 'rgr/check-for-clock-out-note)
 #+end_src
**** Dynamically adjust tag position
 #+index: Tag!position
 Here is a bit of code that allows you to have the tags always
 right-adjusted in the buffer.

 This is useful when you have bigger window than default window-size
 and you dislike the aesthetics of having the tag in the middle of the
 line.

 This hack solves the problem of adjusting it whenever you change the
 window size.
 Before saving it will revert the file to having the tag position be
 left-adjusted so that if you track your files with version control,
 you won't run into artificial diffs just because the window-size
 changed.

 *IMPORTANT*: This is probably slow on very big files.

 #+begin_src emacs-lisp
 (setq ba/org-adjust-tags-column t)

 (defun ba/org-adjust-tags-column-reset-tags ()
   "In org-mode buffers it will reset tag position according to
 `org-tags-column'."
   (when (and
          (not (string= (buffer-name) "*Remember*"))
          (eql major-mode 'org-mode))
     (let ((b-m-p (buffer-modified-p)))
       (condition-case nil
           (save-excursion
             (goto-char (point-min))
             (command-execute 'outline-next-visible-heading)
             ;; disable (message) that org-set-tags generates
             (flet ((message (&rest ignored) nil))
               (org-set-tags 1 t))
             (set-buffer-modified-p b-m-p))
         (error nil)))))

 (defun ba/org-adjust-tags-column-now ()
   "Right-adjust `org-tags-column' value, then reset tag position."
   (set (make-local-variable 'org-tags-column)
	(- (- (window-width) (length org-ellipsis))))
   (ba/org-adjust-tags-column-reset-tags))

 (defun ba/org-adjust-tags-column-maybe ()
   "If `ba/org-adjust-tags-column' is set to non-nil, adjust tags."
   (when ba/org-adjust-tags-column
     (ba/org-adjust-tags-column-now)))

 (defun ba/org-adjust-tags-column-before-save ()
   "Tags need to be left-adjusted when saving."
   (when ba/org-adjust-tags-column
      (setq org-tags-column 1)
      (ba/org-adjust-tags-column-reset-tags)))

 (defun ba/org-adjust-tags-column-after-save ()
   "Revert left-adjusted tag position done by before-save hook."
   (ba/org-adjust-tags-column-maybe)
   (set-buffer-modified-p nil))

 ; automatically align tags on right-hand side
 (add-hook 'window-configuration-change-hook
           'ba/org-adjust-tags-column-maybe)
 (add-hook 'before-save-hook 'ba/org-adjust-tags-column-before-save)
 (add-hook 'after-save-hook 'ba/org-adjust-tags-column-after-save)
 (add-hook 'org-agenda-mode-hook '(lambda ()
                                   (setq org-agenda-tags-column (- (window-width)))))

 ; between invoking org-refile and displaying the prompt (which
 ; triggers window-configuration-change-hook) tags might adjust,
 ; which invalidates the org-refile cache
 (defadvice org-refile (around org-refile-disable-adjust-tags)
   "Disable dynamically adjusting tags"
   (let ((ba/org-adjust-tags-column nil))
     ad-do-it))
 (ad-activate 'org-refile)
 #+end_src
**** Use an "attach" link type to open files without worrying about their location
 #+index: Link!Attach
 -- Darlan Cavalcante Moreira

 In the setup part in my org-files I put:

 #+begin_src org
   ,#+LINK: attach elisp:(org-open-file (org-attach-expand "%s"))
 #+end_src org

 Now I can use the "attach" link type, but org will ask me if I want to
 allow executing the elisp code.  To avoid this you can even set
 org-confirm-elisp-link-function to nil (I don't like this because it allows
 any elisp code in links) or you can set org-confirm-elisp-link-not-regexp
 appropriately.

 In my case I use

 : (setq org-confirm-elisp-link-not-regexp "org-open-file")

 This works very well.

*** Org Agenda and Task Management
**** Make it easier to set org-agenda-files from multiple directories
 #+index: Agenda!Files
 - Matt Lundin

 #+begin_src emacs-lisp
 (defun my-org-list-files (dirs ext)
   "Function to create list of org files in multiple subdirectories.
 This can be called to generate a list of files for
 org-agenda-files or org-refile-targets.

 DIRS is a list of directories.

 EXT is a list of the extensions of files to be included."
   (let ((dirs (if (listp dirs)
                   dirs
                 (list dirs)))
         (ext (if (listp ext)
                  ext
		(list ext)))
         files)
     (mapc
      (lambda (x)
	(mapc
         (lambda (y)
           (setq files
                 (append files
                         (file-expand-wildcards
                          (concat (file-name-as-directory x) "*" y)))))
         ext))
      dirs)
     (mapc
      (lambda (x)
	(when (or (string-match "/.#" x)
                  (string-match "#$" x))
          (setq files (delete x files))))
      files)
     files))

 (defvar my-org-agenda-directories '("~/org/")
   "List of directories containing org files.")
 (defvar my-org-agenda-extensions '(".org")
   "List of extensions of agenda files")

 (setq my-org-agenda-directories '("~/org/" "~/work/"))
 (setq my-org-agenda-extensions '(".org" ".ref"))

 (defun my-org-set-agenda-files ()
   (interactive)
   (setq org-agenda-files (my-org-list-files
                           my-org-agenda-directories
                           my-org-agenda-extensions)))

 (my-org-set-agenda-files)
 #+end_src

 The code above will set your "default" agenda files to all files
 ending in ".org" and ".ref" in the directories "~/org/" and "~/work/".
 You can change these values by setting the variables
 my-org-agenda-extensions and my-org-agenda-directories. The function
 my-org-agenda-files-by-filetag uses these two variables to determine
 which files to search for filetags (i.e., the larger set from which
 the subset will be drawn).

 You can also easily use my-org-list-files to "mix and match"
 directories and extensions to generate different lists of agenda
 files.

**** Restrict org-agenda-files by filetag
 #+index: Agenda!Files
   :PROPERTIES:
   :CUSTOM_ID: set-agenda-files-by-filetag
   :END:
 - Matt Lundin

 It is often helpful to limit yourself to a subset of your agenda
 files. For instance, at work, you might want to see only files related
 to work (e.g., bugs, clientA, projectxyz, etc.). The FAQ has helpful
 information on filtering tasks using [[file:org-faq.org::#limit-agenda-with-tag-filtering][filetags]] and [[file:org-faq.org::#limit-agenda-with-category-match][custom agenda
 commands]]. These solutions, however, require reapplying a filter each
 time you call the agenda or writing several new custom agenda commands
 for each context. Another solution is to use directories for different
 types of tasks and to change your agenda files with a function that
 sets org-agenda-files to the appropriate directory. But this relies on
 hard and static boundaries between files.

 The following functions allow for a more dynamic approach to selecting
 a subset of files based on filetags:

 #+begin_src emacs-lisp
 (defun my-org-agenda-restrict-files-by-filetag (&optional tag)
   "Restrict org agenda files only to those containing filetag."
   (interactive)
   (let* ((tagslist (my-org-get-all-filetags))
          (ftag (or tag
                    (completing-read "Tag: "
                                     (mapcar 'car tagslist)))))
     (org-agenda-remove-restriction-lock 'noupdate)
     (put 'org-agenda-files 'org-restrict (cdr (assoc ftag tagslist)))
     (setq org-agenda-overriding-restriction 'files)))

 (defun my-org-get-all-filetags ()
   "Get list of filetags from all default org-files."
   (let ((files org-agenda-files)
         tagslist x)
     (save-window-excursion
       (while (setq x (pop files))
         (set-buffer (find-file-noselect x))
         (mapc
          (lambda (y)
            (let ((tagfiles (assoc y tagslist)))
              (if tagfiles
                  (setcdr tagfiles (cons x (cdr tagfiles)))
		(add-to-list 'tagslist (list y x)))))
          (my-org-get-filetags)))
       tagslist)))

 (defun my-org-get-filetags ()
   "Get list of filetags for current buffer"
   (let ((ftags org-file-tags)
         x)
     (mapcar
      (lambda (x)
	(org-substring-no-properties x))
      ftags)))
 #+end_src

 Calling my-org-agenda-restrict-files-by-filetag results in a prompt
 with all filetags in your "normal" agenda files. When you select a
 tag, org-agenda-files will be restricted to only those files
 containing the filetag. To release the restriction, type C-c C-x >
 (org-agenda-remove-restriction-lock).

**** Highlight the agenda line under cursor
 #+index: Agenda!Highlight
 This is useful to make sure what task you are operating on.

 #+BEGIN_SRC emacs-lisp
 (add-hook 'org-agenda-mode-hook '(lambda () (hl-line-mode 1)))
 #+END_SRC

 Under XEmacs:

 #+BEGIN_SRC emacs-lisp
 ;; hl-line seems to be only for emacs
 (require 'highline)
 (add-hook 'org-agenda-mode-hook '(lambda () (highline-mode 1)))

 ;; highline-mode does not work straightaway in tty mode.
 ;; I use a black background
 (custom-set-faces
   '(highline-face ((((type tty) (class color))
                     (:background "white" :foreground "black")))))
 #+END_SRC

**** Split frame horizontally for agenda
 #+index: Agenda!frame
 If you would like to split the frame into two side-by-side windows when
 displaying the agenda, try this hack from Jan Rehders, which uses the
 `toggle-window-split' from

 http://www.emacswiki.org/cgi-bin/wiki/ToggleWindowSplit

 #+BEGIN_SRC emacs-lisp
 ;; Patch org-mode to use vertical splitting
 (defadvice org-prepare-agenda (after org-fix-split)
   (toggle-window-split))
 (ad-activate 'org-prepare-agenda)
 #+END_SRC

**** Automatically add an appointment when clocking in a task
 #+index: Clock!Automatically add an appointment when clocking in a task
 #+index: Appointment!Automatically add an appointment when clocking in a task
 #+BEGIN_SRC emacs-lisp
 ;; Make sure you have a sensible value for `appt-message-warning-time'
 (defvar bzg-org-clock-in-appt-delay 100
   "Number of minutes for setting an appointment by clocking-in")
 #+END_SRC

 This function let's you add an appointment for the current entry.
 This can be useful when you need a reminder.

 #+BEGIN_SRC emacs-lisp
 (defun bzg-org-clock-in-add-appt (&optional n)
   "Add an appointment for the Org entry at point in N minutes."
   (interactive)
   (save-excursion
     (org-back-to-heading t)
     (looking-at org-complex-heading-regexp)
     (let* ((msg (match-string-no-properties 4))
	    (ct-time (decode-time))
	    (appt-min (+ (cadr ct-time)
			 (or n bzg-org-clock-in-appt-delay)))
	    (appt-time ; define the time for the appointment
	     (progn (setf (cadr ct-time) appt-min) ct-time)))
       (appt-add (format-time-string
		  "%H:%M" (apply 'encode-time appt-time)) msg)
       (if (interactive-p) (message "New appointment for %s" msg)))))
 #+END_SRC

 You can advise =org-clock-in= so that =C-c C-x C-i= will automatically
 add an appointment:

 #+BEGIN_SRC emacs-lisp
 (defadvice org-clock-in (after org-clock-in-add-appt activate)
   "Add an appointment when clocking a task in."
   (bzg-org-clock-in-add-appt))
 #+END_SRC

 You may also want to delete the associated appointment when clocking
 out.  This function does this:

 #+BEGIN_SRC emacs-lisp
 (defun bzg-org-clock-out-delete-appt nil
   "When clocking out, delete any associated appointment."
   (interactive)
   (save-excursion
     (org-back-to-heading t)
     (looking-at org-complex-heading-regexp)
     (let* ((msg (match-string-no-properties 4)))
       (setq appt-time-msg-list
	     (delete nil
		     (mapcar
		      (lambda (appt)
			(if (not (string-match (regexp-quote msg)
					       (cadr appt))) appt))
		      appt-time-msg-list)))
       (appt-check))))
 #+END_SRC

 And here is the advice for =org-clock-out= (=C-c C-x C-o=)

 #+BEGIN_SRC emacs-lisp
 (defadvice org-clock-out (before org-clock-out-delete-appt activate)
   "Delete an appointment when clocking a task out."
   (bzg-org-clock-out-delete-appt))
 #+END_SRC

 *IMPORTANT*: You can add appointment by clocking in in both an
 =org-mode= and an =org-agenda-mode= buffer.  But clocking out from
 agenda buffer with the advice above will bring an error.

**** Using external programs for appointments reminders
 #+index: Appointment!reminders
 Read this rich [[http://comments.gmane.org/gmane.emacs.orgmode/46641][thread]] from the org-mode list.

**** Remove from agenda time grid lines that are in an appointment
 #+index: Agenda!time grid
 #+index: Appointment!Remove from agenda time grid lines
 The agenda shows lines for the time grid.  Some people think that
 these lines are a distraction when there are appointments at those
 times.  You can get rid of the lines which coincide exactly with the
 beginning of an appointment.  Michael Ekstrand has written a piece of
 advice that also removes lines that are somewhere inside an
 appointment:

 #+begin_src emacs-lisp
 (defun org-time-to-minutes (time)
   "Convert an HHMM time to minutes"
   (+ (* (/ time 100) 60) (% time 100)))

 (defun org-time-from-minutes (minutes)
   "Convert a number of minutes to an HHMM time"
   (+ (* (/ minutes 60) 100) (% minutes 60)))

 (defadvice org-agenda-add-time-grid-maybe (around mde-org-agenda-grid-tweakify
                                                   (list ndays todayp))
   (if (member 'remove-match (car org-agenda-time-grid))
       (flet ((extract-window
               (line)
               (let ((start (get-text-property 1 'time-of-day line))
                     (dur (get-text-property 1 'duration line)))
                 (cond
                  ((and start dur)
                   (cons start
                         (org-time-from-minutes
                          (+ dur (org-time-to-minutes start)))))
                  (start start)
                  (t nil)))))
         (let* ((windows (delq nil (mapcar 'extract-window list)))
		(org-agenda-time-grid
                 (list (car org-agenda-time-grid)
                       (cadr org-agenda-time-grid)
                       (remove-if
			(lambda (time)
                          (find-if (lambda (w)
                                     (if (numberp w)
                                         (equal w time)
                                       (and (>= time (car w))
                                            (< time (cdr w)))))
                                   windows))
			(caddr org-agenda-time-grid)))))
           ad-do-it))
     ad-do-it))
 (ad-activate 'org-agenda-add-time-grid-maybe)
 #+end_src
**** Disable version control for Org mode agenda files
 #+index: Agenda!Files
 -- David Maus

 Even if you use Git to track your agenda files you might not need
 vc-mode to be enabled for these files.

 #+begin_src emacs-lisp
 (add-hook 'find-file-hook 'dmj/disable-vc-for-agenda-files-hook)
 (defun dmj/disable-vc-for-agenda-files-hook ()
   "Disable vc-mode for Org agenda files."
   (if (and (fboundp 'org-agenda-file-p)
            (org-agenda-file-p (buffer-file-name)))
       (remove-hook 'find-file-hook 'vc-find-file-hook)
     (add-hook 'find-file-hook 'vc-find-file-hook)))
 #+end_src

**** Easy customization of TODO colors
 #+index: Customization!Todo keywords
 #+index: Todo keywords!Customization

 -- Ryan C. Thompson

 Here is some code I came up with some code to make it easier to
 customize the colors of various TODO keywords. As long as you just
 want a different color and nothing else, you can customize the
 variable org-todo-keyword-faces and use just a string color (i.e. a
 string of the color name) as the face, and then org-get-todo-face
 will convert the color to a face, inheriting everything else from
 the standard org-todo face.

 To demonstrate, I currently have org-todo-keyword-faces set to

 #+BEGIN_SRC emacs-lisp
 (("IN PROGRESS" . "dark orange")
  ("WAITING" . "red4")
  ("CANCELED" . "saddle brown"))
 #+END_SRC

   Here's the code, in a form you can put in your =.emacs=

 #+BEGIN_SRC emacs-lisp
 (eval-after-load 'org-faces
  '(progn
     (defcustom org-todo-keyword-faces nil
       "Faces for specific TODO keywords.
 This is a list of cons cells, with TODO keywords in the car and
 faces in the cdr.  The face can be a symbol, a color, or a
 property list of attributes, like (:foreground \"blue\" :weight
 bold :underline t)."
       :group 'org-faces
       :group 'org-todo
       :type '(repeat
               (cons
		(string :tag "Keyword")
		(choice color (sexp :tag "Face")))))))

 (eval-after-load 'org
  '(progn
     (defun org-get-todo-face-from-color (color)
       "Returns a specification for a face that inherits from org-todo
  face and has the given color as foreground. Returns nil if
  color is nil."
       (when color
         `(:inherit org-warning :foreground ,color)))

     (defun org-get-todo-face (kwd)
       "Get the right face for a TODO keyword KWD.
 If KWD is a number, get the corresponding match group."
       (if (numberp kwd) (setq kwd (match-string kwd)))
       (or (let ((face (cdr (assoc kwd org-todo-keyword-faces))))
             (if (stringp face)
                 (org-get-todo-face-from-color face)
               face))
           (and (member kwd org-done-keywords) 'org-done)
           'org-todo))))
 #+END_SRC

**** Add an effort estimate on the fly when clocking in
 #+index: Effort estimate!Add when clocking in
 #+index: Clock!Effort estimate
 You can use =org-clock-in-prepare-hook= to add an effort estimate.
 This way you can easily have a "tea-timer" for your tasks when they
 don't already have an effort estimate.

 #+begin_src emacs-lisp
 (add-hook 'org-clock-in-prepare-hook
	   'my-org-mode-ask-effort)

 (defun my-org-mode-ask-effort ()
   "Ask for an effort estimate when clocking in."
   (unless (org-entry-get (point) "Effort")
     (let ((effort
	    (completing-read
	     "Effort: "
	     (org-entry-get-multivalued-property (point) "Effort"))))
       (unless (equal effort "")
	 (org-set-property "Effort" effort)))))
 #+end_src

 Or you can use a default effort for such a timer:

 #+begin_src emacs-lisp
 (add-hook 'org-clock-in-prepare-hook
	   'my-org-mode-add-default-effort)

 (defvar org-clock-default-effort "1:00")

 (defun my-org-mode-add-default-effort ()
   "Add a default effort estimation."
   (unless (org-entry-get (point) "Effort")
     (org-set-property "Effort" org-clock-default-effort)))
 #+end_src

**** Use idle timer for automatic agenda views
 #+index: Agenda view!Refresh
 From John Wiegley's mailing list post (March 18, 2010):

 #+begin_quote
 I have the following snippet in my .emacs file, which I find very
 useful. Basically what it does is that if I don't touch my Emacs for 5
 minutes, it displays the current agenda. This keeps my tasks "always
 in mind" whenever I come back to Emacs after doing something else,
 whereas before I had a tendency to forget that it was there.
 #+end_quote

   - [[http://mid.gmane.org/55590EA7-C744-44E5-909F-755F0BBE452D@gmail.com][John Wiegley: Displaying your Org agenda after idle time]]

 #+begin_src emacs-lisp
 (defun jump-to-org-agenda ()
   (interactive)
   (let ((buf (get-buffer "*Org Agenda*"))
         wind)
     (if buf
         (if (setq wind (get-buffer-window buf))
             (select-window wind)
           (if (called-interactively-p)
               (progn
                 (select-window (display-buffer buf t t))
                 (org-fit-window-to-buffer)
                 ;; (org-agenda-redo)
                 )
             (with-selected-window (display-buffer buf)
               (org-fit-window-to-buffer)
               ;; (org-agenda-redo)
               )))
       (call-interactively 'org-agenda-list)))
   ;;(let ((buf (get-buffer "*Calendar*")))
   ;;  (unless (get-buffer-window buf)
   ;;    (org-agenda-goto-calendar)))
   )

 (run-with-idle-timer 300 t 'jump-to-org-agenda)
 #+end_src

 #+results:
 : [nil 0 300 0 t jump-to-org-agenda nil idle]

**** Refresh the agenda view regularly
 #+index: Agenda view!Refresh
 Hack sent by Kiwon Um:

 #+begin_src emacs-lisp
 (defun kiwon/org-agenda-redo-in-other-window ()
   "Call org-agenda-redo function even in the non-agenda buffer."
   (interactive)
   (let ((agenda-window (get-buffer-window org-agenda-buffer-name t)))
     (when agenda-window
       (with-selected-window agenda-window (org-agenda-redo)))))
 (run-at-time nil 300 'kiwon/org-agenda-redo-in-other-window)
 #+end_src

**** Reschedule agenda items to today with a single command
 #+index: Agenda!Reschedule
 This was suggested by Carsten in reply to David Abrahams:

 #+begin_example emacs-lisp
 (defun org-agenda-reschedule-to-today ()
   (interactive)
   (flet ((org-read-date (&rest rest) (current-time)))
     (call-interactively 'org-agenda-schedule)))
 #+end_example

**** Mark subtree DONE along with all subheadings
 #+index: Subtree!subheadings
 Bernt Hansen [[http://permalink.gmane.org/gmane.emacs.orgmode/44693][suggested]] this command:

 #+begin_src emacs-lisp
 (defun bh/mark-subtree-done ()
   (interactive)
   (org-mark-subtree)
   (let ((limit (point)))
     (save-excursion
       (exchange-point-and-mark)
       (while (> (point) limit)
	 (org-todo "DONE")
	 (outline-previous-visible-heading 1))
       (org-todo "DONE"))))
 #+end_src

 Then M-x bh/mark-subtree-done.

**** Mark heading done when all checkboxes are checked.
     :PROPERTIES:
     :CUSTOM_ID: mark-done-when-all-checkboxes-checked
     :END:

 #+index: Checkbox

 An item consists of a list with checkboxes.  When all of the
 checkboxes are checked, the item should be considered complete and its
 TODO state should be automatically changed to DONE. The code below
 does that. This version is slightly enhanced over the one in the
 mailing list (see
 http://thread.gmane.org/gmane.emacs.orgmode/42715/focus=42721) to
 reset the state back to TODO if a checkbox is unchecked.

 Note that the code requires that a checkbox statistics cookie (the [/]
 or [%] thingie in the headline - see the [[http://orgmode.org/manual/Checkboxes.html#Checkboxes][Checkboxes]] section in the
 manual) be present in order for it to work. Note also that it is too
 dumb to figure out whether the item has a TODO state in the first
 place: if there is a statistics cookie, a TODO/DONE state will be
 added willy-nilly any time that the statistics cookie is changed.

 #+begin_src emacs-lisp
   ;; see http://thread.gmane.org/gmane.emacs.orgmode/42715
   (eval-after-load 'org-list
     '(add-hook 'org-checkbox-statistics-hook (function ndk/checkbox-list-complete)))
  
   (defun ndk/checkbox-list-complete ()
     (save-excursion
       (org-back-to-heading t)
       (let ((beg (point)) end)
         (end-of-line)
         (setq end (point))
         (goto-char beg)
         (if (re-search-forward "\\[\\([0-9]*%\\)\\]\\|\\[\\([0-9]*\\)/\\([0-9]*\\)\\]" end t)
               (if (match-end 1)
                   (if (equal (match-string 1) "100%")
                       ;; all done - do the state change
                       (org-todo 'done)
                     (org-todo 'todo))
                 (if (and (> (match-end 2) (match-beginning 2))
                          (equal (match-string 2) (match-string 3)))
                     (org-todo 'done)
                   (org-todo 'todo)))))))
 #+end_src

**** Links to custom agenda views
     :PROPERTIES:
     :CUSTOM_ID: links-to-agenda-views
     :END:
 #+index: Agenda view!Links to
 This hack was [[http://lists.gnu.org/archive/html/emacs-orgmode/2012-08/msg00986.html][posted to the mailing list]] by Nathan Neff.

 If you have custom agenda commands defined to some key, say w, then
 the following will serve as a link to the custom agenda buffer.
 : [[elisp:(org-agenda nil "w")][Show Waiting Tasks]]

 Clicking on it will prompt if you want to execute the elisp code.  If
 you would rather not have the prompt or would want to respond with a
 single letter, ~y~ or ~n~, take a look at the docstrings of the
 variables =org-confirm-elisp-link-function= and
 =org-confirm-elisp-link-not-regexp=.  Please take special note of the
 security risk associated with completely disabling the prompting
 before you proceed.

*** Exporting org files
**** Export Org to Org and handle includes.
 #+index: Export!handle includes
 Nick Dokos came up with this useful function:

 #+begin_src emacs-lisp
 (defun org-to-org-handle-includes ()
   "Copy the contents of the current buffer to OUTFILE,
 recursively processing #+INCLUDEs."
   (let* ((s (buffer-string))
	  (fname (buffer-file-name))
	  (ofname (format "%s.I.org" (file-name-sans-extension fname))))
     (setq result
	   (with-temp-buffer
	     (insert s)
	     (org-export-handle-include-files-recurse)
	     (buffer-string)))
     (find-file ofname)
     (delete-region (point-min) (point-max))
     (insert result)
     (save-buffer)))
 #+end_src

**** Specifying LaTeX commands to floating environments
     :PROPERTIES:
     :CUSTOM_ID: latex-command-for-floats
     :END:

 #+index: Export!LaTeX
 The keyword ~placement~ can be used to specify placement options to
 floating environments (like =\begin{figure}= and =\begin{table}=}) in
 LaTeX export. Org passes along everything passed in options as long as
 there are no spaces. One can take advantage of this to pass other
 LaTeX commands and have their scope limited to the floating
 environment.

 For example one can set the fontsize of a table different from the
 default normal size by putting something like =\footnotesize= right
 after the placement options. During LaTeX export using the
 ~#+ATTR_LaTeX:~ line below:

 #+begin_src org
   ,#+ATTR_LaTeX: placement=[<options>]\footnotesize
 #+end_src

 exports the associated floating environment as shown in the following
 block.

 #+begin_src latex
 \begin{table}[<options>]\footnotesize
 ...
 \end{table}
 #+end_src

 It should be noted that this hack does not work for beamer export of
 tables since the =table= environment is not used. As an ugly
 workaround, one can use the following:

 #+begin_src org
   ,#+LATEX: {\footnotesize
   ,#+ATTR_LaTeX: align=rr
   ,| some | table |
   ,|------+-------|
   ,| ..   | ..    |
   ,#+LATEX: }
 #+end_src

**** Styling code sections with CSS

 #+index: HTML!Styling code sections with CSS

 Code sections (marked with =#+begin_src= and =#+end_src=) are exported
 to HTML using =<pre>= tags, and assigned CSS classes by their content
 type.  For example, Perl content will have an opening tag like
 =<pre class="src src-perl">=.  You can use those classes to add styling
 to the output, such as here where a small language tag is added at the
 top of each kind of code box:

 #+begin_src lisp
 (setq org-export-html-style
  "<style type=\"text/css\">
     <!--/*--><![CDATA[/*><!--*/
       .src             { background-color: #F5FFF5; position: relative; overflow: visible; }
       .src:before      { position: absolute; top: -15px; background: #ffffff; padding: 1px; border: 1px solid #000000; font-size: small; }
       .src-sh:before   { content: 'sh'; }
       .src-bash:before { content: 'sh'; }
       .src-R:before    { content: 'R'; }
       .src-perl:before { content: 'Perl'; }
       .src-sql:before  { content: 'SQL'; }
       .example         { background-color: #FFF5F5; }
     /*]]>*/-->
  </style>")
 #+end_src

 Additionally, we use color to distinguish code output (the =.example=
 class) from input (all the =.src-*= classes).

*** Babel

**** How do I preview LaTeX fragments when in a LaTeX source block?

 When editing =LaTeX= source blocks, you may want to preview LaTeX fragments
 just like in an Org-mode buffer.  You can do this by using the usual
 keybinding =C-c C-x C-l= after loading this snipped:

 #+BEGIN_SRC emacs-lisp
 (define-key org-src-mode-map "\C-c\C-x\C-l" 'org-edit-preview-latex-fragment)

 (defun org-edit-preview-latex-fragment ()
   "Write latex fragment from source to parent buffer and preview it."
   (interactive)
   (org-src-in-org-buffer (org-preview-latex-fragment)))
 #+END_SRC

 Thanks to Sebastian Hofer for sharing this.

** Hacking Org: Working with Org-mode and other Emacs Packages.
*** org-remember-anything

 #+index: Remember!Anything

 [[http://www.emacswiki.org/cgi-bin/wiki/Anything][Anything]] users may find the snippet below interesting:

 #+BEGIN_SRC emacs-lisp
 (defvar org-remember-anything
   '((name . "Org Remember")
     (candidates . (lambda () (mapcar 'car org-remember-templates)))
     (action . (lambda (name)
                 (let* ((orig-template org-remember-templates)
			(org-remember-templates
                         (list (assoc name orig-template))))
                   (call-interactively 'org-remember))))))
 #+END_SRC

 You can add it to your 'anything-sources' variable and open remember directly
 from anything. I imagine this would be more interesting for people with many
 remember templates, so that you are out of keys to assign those to.

*** Org-mode and saveplace.el

 Fix a problem with =saveplace.el= putting you back in a folded position:

 #+begin_src emacs-lisp
 (add-hook 'org-mode-hook
           (lambda ()
	     (when (outline-invisible-p)
	       (save-excursion
		 (outline-previous-visible-heading 1)
		 (org-show-subtree)))))
 #+end_src

*** Using ido-mode for org-refile (and archiving via refile)

 First set up ido-mode, for example using:

 #+begin_src emacs-lisp
 ; use ido mode for completion
 (setq ido-everywhere t)
 (setq ido-enable-flex-matching t)
 (setq ido-max-directory-size 100000)
 (ido-mode (quote both))
 #+end_src

 Now to enable it in org-mode, use the following:
 #+begin_src emacs-lisp
 (setq org-completion-use-ido t)
 (setq org-refile-use-outline-path nil)
 (setq org-refile-allow-creating-parent-nodes 'confirm)
 #+end_src
 The last line enables the creation of nodes on the fly.

 If you refile into files that are not in your agenda file list, you can add them as target like this (replace file1\_done, etc with your files):
 #+begin_src emacs-lisp
 (setq org-refile-targets '((org-agenda-files :maxlevel . 5) (("~/org/file1_done" "~/org/file2_done") :maxlevel . 5) ))
 #+end_src

 For refiling it is often not useful to include targets that have a DONE state. It's easy to remove them by using the verify-refile-target hook.
 #+begin_src emacs-lisp
 ; Exclude DONE state tasks from refile targets; taken from http://doc.norang.ca/org-mode.html
 ; added check to only include headlines, e.g. line must have at least one child
 (defun my/verify-refile-target ()
   "Exclude todo keywords with a DONE state from refile targets"
   (or (not (member (nth 2 (org-heading-components)) org-done-keywords)))
       (save-excursion (org-goto-first-child))
   )
 (setq org-refile-target-verify-function 'my/verify-refile-target)
 #+end_src
 Now when looking for a refile target, you can use the full power of ido to find them. Ctrl-R can be used to switch between different options that ido offers.

*** Using ido-completing-read to find attachments

 #+index: Attachment!ido completion

 -- Matt Lundin.

 Org-attach is great for quickly linking files to a project. But if you
 use org-attach extensively you might find yourself wanting to browse
 all the files you've attached to org headlines. This is not easy to do
 manually, since the directories containing the files are not human
 readable (i.e., they are based on automatically generated ids). Here's
 some code to browse those files using ido (obviously, you need to be
 using ido):

 #+begin_src emacs-lisp
 (load-library "find-lisp")

 ;; Adapted from http://www.emacswiki.org/emacs/RecentFiles

 (defun my-ido-find-org-attach ()
   "Find files in org-attachment directory"
   (interactive)
   (let* ((enable-recursive-minibuffers t)
          (files (find-lisp-find-files org-attach-directory "."))
          (file-assoc-list
           (mapcar (lambda (x)
                     (cons (file-name-nondirectory x)
                           x))
                   files))
          (filename-list
           (remove-duplicates (mapcar #'car file-assoc-list)
                              :test #'string=))
          (filename (ido-completing-read "Org attachments: " filename-list nil t))
          (longname (cdr (assoc filename file-assoc-list))))
     (ido-set-current-directory
      (if (file-directory-p longname)
          longname
	(file-name-directory longname)))
     (setq ido-exit 'refresh
           ido-text-init ido-text
           ido-rotate-temp t)
     (exit-minibuffer)))

 (add-hook 'ido-setup-hook 'ido-my-keys)

 (defun ido-my-keys ()
   "Add my keybindings for ido."
   (define-key ido-completion-map (kbd "C-;") 'my-ido-find-org-attach))
 #+end_src

 To browse your org attachments using ido fuzzy matching and/or the
 completion buffer, invoke ido-find-file as usual (=C-x C-f=) and then
 press =C-;=.

*** Link to Gnus messages by Message-Id
 #+index: Link!Gnus message by Message-Id
 In a [[http://thread.gmane.org/gmane.emacs.orgmode/8860][recent thread]] on the Org-Mode mailing list, there was some
 discussion about linking to Gnus messages without encoding the folder
 name in the link.  The following code hooks in to the store-link
 function in Gnus to capture links by Message-Id when in nnml folders,
 and then provides a link type "mid" which can open this link.  The
 =mde-org-gnus-open-message-link= function uses the
 =mde-mid-resolve-methods= variable to determine what Gnus backends to
 scan.  It will go through them, in order, asking each to locate the
 message and opening it from the first one that reports success.

 It has only been tested with a single nnml backend, so there may be
 bugs lurking here and there.

 The logic for finding the message was adapted from [[http://www.emacswiki.org/cgi-bin/wiki/FindMailByMessageId][an Emacs Wiki
 article]].

 #+begin_src emacs-lisp
 ;; Support for saving Gnus messages by Message-ID
 (defun mde-org-gnus-save-by-mid ()
   (when (memq major-mode '(gnus-summary-mode gnus-article-mode))
     (when (eq major-mode 'gnus-article-mode)
       (gnus-article-show-summary))
     (let* ((group gnus-newsgroup-name)
            (method (gnus-find-method-for-group group)))
       (when (eq 'nnml (car method))
         (let* ((article (gnus-summary-article-number))
		(header (gnus-summary-article-header article))
		(from (mail-header-from header))
		(message-id
                 (save-match-data
                   (let ((mid (mail-header-id header)))
                     (if (string-match "<\\(.*\\)>" mid)
                         (match-string 1 mid)
                       (error "Malformed message ID header %s" mid)))))
		(date (mail-header-date header))
		(subject (gnus-summary-subject-string)))
           (org-store-link-props :type "mid" :from from :subject subject
                                 :message-id message-id :group group
                                 :link (org-make-link "mid:" message-id))
           (apply 'org-store-link-props
                  :description (org-email-link-description)
                  org-store-link-plist)
           t)))))

 (defvar mde-mid-resolve-methods '()
   "List of methods to try when resolving message ID's.  For Gnus,
 it is a cons of 'gnus and the select (type and name).")
 (setq mde-mid-resolve-methods
       '((gnus nnml "")))

 (defvar mde-org-gnus-open-level 1
   "Level at which Gnus is started when opening a link")
 (defun mde-org-gnus-open-message-link (msgid)
   "Open a message link with Gnus"
   (require 'gnus)
   (require 'org-table)
   (catch 'method-found
     (message "[MID linker] Resolving %s" msgid)
     (dolist (method mde-mid-resolve-methods)
       (cond
	((and (eq (car method) 'gnus)
              (eq (cadr method) 'nnml))
         (funcall (cdr (assq 'gnus org-link-frame-setup))
                  mde-org-gnus-open-level)
         (when gnus-other-frame-object
           (select-frame gnus-other-frame-object))
         (let* ((msg-info (nnml-find-group-number
                           (concat "<" msgid ">")
                           (cdr method)))
		(group (and msg-info (car msg-info)))
		(message (and msg-info (cdr msg-info)))
		(qname (and group
                            (if (gnus-methods-equal-p
                                 (cdr method)
                                 gnus-select-method)
				group
                              (gnus-group-full-name group (cdr method))))))
           (when msg-info
             (gnus-summary-read-group qname nil t)
             (gnus-summary-goto-article message nil t))
           (throw 'method-found t)))
	(t (error "Unknown link type"))))))

 (eval-after-load 'org-gnus
   '(progn
      (add-to-list 'org-store-link-functions 'mde-org-gnus-save-by-mid)
      (org-add-link-type "mid" 'mde-org-gnus-open-message-link)))
 #+end_src

*** Store link to a message when sending in Gnus
 #+index: Link!Store link to a message when sending in Gnus
 Ulf Stegemann came up with this solution (see his [[http://www.mail-archive.com/emacs-orgmode@gnu.org/msg33278.html][original message]]):

 #+begin_src emacs-lisp
 (defun ulf-message-send-and-org-gnus-store-link (&optional arg)
   "Send message with `message-send-and-exit' and store org link to message copy.
 If multiple groups appear in the Gcc header, the link refers to
 the copy in the last group."
   (interactive "P")
     (save-excursion
       (save-restriction
	 (message-narrow-to-headers)
	 (let ((gcc (car (last
			  (message-unquote-tokens
			   (message-tokenize-header
			    (mail-fetch-field "gcc" nil t) " ,")))))
	       (buf (current-buffer))
	       (message-kill-buffer-on-exit nil)
	       id to from subject desc link newsgroup xarchive)
         (message-send-and-exit arg)
         (or
          ;; gcc group found ...
          (and gcc
               (save-current-buffer
                 (progn (set-buffer buf)
			(setq id (org-remove-angle-brackets
                                  (mail-fetch-field "Message-ID")))
			(setq to (mail-fetch-field "To"))
			(setq from (mail-fetch-field "From"))
			(setq subject (mail-fetch-field "Subject"))))
               (org-store-link-props :type "gnus" :from from :subject subject
                                     :message-id id :group gcc :to to)
               (setq desc (org-email-link-description))
               (setq link (org-gnus-article-link
                           gcc newsgroup id xarchive))
               (setq org-stored-links
                     (cons (list link desc) org-stored-links)))
          ;; no gcc group found ...
          (message "Can not create Org link: No Gcc header found."))))))

 (define-key message-mode-map [(control c) (control meta c)]
   'ulf-message-send-and-org-gnus-store-link)
 #+end_src

*** Send html messages and attachments with Wanderlust
   -- David Maus

 /Note/: The module [[file:org-contrib/org-mime.org][Org-mime]] in Org's contrib directory provides
 similar functionality for both Wanderlust and Gnus.  The hack below is
 still somewhat different: It allows you to toggle sending of html
 messages within Wanderlust transparently.  I.e. html markup of the
 message body is created right before sending starts.

**** Send HTML message

 Putting the code below in your .emacs adds following four functions:

 - dmj/wl-send-html-message

   Function that does the job: Convert everything between "--text
   follows this line--" and first mime entity (read: attachment) or
   end of buffer into html markup using `org-export-region-as-html'
   and replaces original body with a multipart MIME entity with the
   plain text version of body and the html markup version.  Thus a
   recipient that prefers html messages can see the html markup,
   recipients that prefer or depend on plain text can see the plain
   text.

   Cannot be called interactively: It is hooked into SEMI's
   `mime-edit-translate-hook' if message should be HTML message.

 - dmj/wl-send-html-message-draft-init

   Cannot be called interactively: It is hooked into WL's
   `wl-mail-setup-hook' and provides a buffer local variable to
   toggle.

 - dmj/wl-send-html-message-draft-maybe

   Cannot be called interactively: It is hooked into WL's
   `wl-draft-send-hook' and hooks `dmj/wl-send-html-message' into
   `mime-edit-translate-hook' depending on whether HTML message is
   toggled on or off

 - dmj/wl-send-html-message-toggle

   Toggles sending of HTML message.  If toggled on, the letters
   "HTML" appear in the mode line.

   Call it interactively!  Or bind it to a key in `wl-draft-mode'.

 If you have to send HTML messages regularly you can set a global
 variable `dmj/wl-send-html-message-toggled-p' to the string "HTML" to
 toggle on sending HTML message by default.

 The image [[http://s11.directupload.net/file/u/15851/48ru5wl3.png][here]] shows an example of how the HTML message looks like in
 Google's web front end.  As you can see you have the whole markup of
 Org at your service: *bold*, /italics/, tables, lists...

 So even if you feel uncomfortable with sending HTML messages at least
 you send HTML that looks quite good.

 #+begin_src emacs-lisp
 (defun dmj/wl-send-html-message ()
   "Send message as html message.
 Convert body of message to html using
   `org-export-region-as-html'."
   (require 'org)
   (save-excursion
     (let (beg end html text)
       (goto-char (point-min))
       (re-search-forward "^--text follows this line--$")
       ;; move to beginning of next line
       (beginning-of-line 2)
       (setq beg (point))
       (if (not (re-search-forward "^--\\[\\[" nil t))
           (setq end (point-max))
         ;; line up
         (end-of-line 0)
         (setq end (point)))
       ;; grab body
       (setq text (buffer-substring-no-properties beg end))
       ;; convert to html
       (with-temp-buffer
         (org-mode)
         (insert text)
         ;; handle signature
         (when (re-search-backward "^-- \n" nil t)
           ;; preserve link breaks in signature
           (insert "\n#+BEGIN_VERSE\n")
           (goto-char (point-max))
           (insert "\n#+END_VERSE\n")
           ;; grab html
           (setq html (org-export-region-as-html
                       (point-min) (point-max) t 'string))))
       (delete-region beg end)
       (insert
	(concat
         "--" "<<alternative>>-{\n"
         "--" "[[text/plain]]\n" text
         "--" "[[text/html]]\n"  html
         "--" "}-<<alternative>>\n")))))

 (defun dmj/wl-send-html-message-toggle ()
   "Toggle sending of html message."
   (interactive)
   (setq dmj/wl-send-html-message-toggled-p
         (if dmj/wl-send-html-message-toggled-p
             nil "HTML"))
   (message "Sending html message toggled %s"
            (if dmj/wl-send-html-message-toggled-p
		"on" "off")))

 (defun dmj/wl-send-html-message-draft-init ()
   "Create buffer local settings for maybe sending html message."
   (unless (boundp 'dmj/wl-send-html-message-toggled-p)
     (setq dmj/wl-send-html-message-toggled-p nil))
   (make-variable-buffer-local 'dmj/wl-send-html-message-toggled-p)
   (add-to-list 'global-mode-string
		'(:eval (if (eq major-mode 'wl-draft-mode)
                            dmj/wl-send-html-message-toggled-p))))

 (defun dmj/wl-send-html-message-maybe ()
   "Maybe send this message as html message.

 If buffer local variable `dmj/wl-send-html-message-toggled-p' is
 non-nil, add `dmj/wl-send-html-message' to
 `mime-edit-translate-hook'."
   (if dmj/wl-send-html-message-toggled-p
       (add-hook 'mime-edit-translate-hook 'dmj/wl-send-html-message)
     (remove-hook 'mime-edit-translate-hook 'dmj/wl-send-html-message)))

 (add-hook 'wl-draft-reedit-hook 'dmj/wl-send-html-message-draft-init)
 (add-hook 'wl-mail-setup-hook 'dmj/wl-send-html-message-draft-init)
 (add-hook 'wl-draft-send-hook 'dmj/wl-send-html-message-maybe)
 #+end_src

**** Attach HTML of region or subtree

 Instead of sending a complete HTML message you might only send parts
 of an Org file as HTML for the poor souls who are plagued with
 non-proportional fonts in their mail program that messes up pretty
 ASCII tables.

 This short function does the trick: It exports region or subtree to
 HTML, prefixes it with a MIME entity delimiter and pushes to killring
 and clipboard.  If a region is active, it uses the region, the
 complete subtree otherwise.

 #+begin_src emacs-lisp
 (defun dmj/org-export-region-as-html-attachment (beg end arg)
   "Export region between BEG and END as html attachment.
 If BEG and END are not set, use current subtree.  Region or
 subtree is exported to html without header and footer, prefixed
 with a mime entity string and pushed to clipboard and killring.
 When called with prefix, mime entity is not marked as
 attachment."
   (interactive "r\nP")
   (save-excursion
     (let* ((beg (if (region-active-p) (region-beginning)
                   (progn
                     (org-back-to-heading)
                     (point))))
            (end (if (region-active-p) (region-end)
                   (progn
                     (org-end-of-subtree)
                     (point))))
            (html (concat "--[[text/html"
                          (if arg "" "\nContent-Disposition: attachment")
                          "]]\n"
                          (org-export-region-as-html beg end t 'string))))
       (when (fboundp 'x-set-selection)
         (ignore-errors (x-set-selection 'PRIMARY html))
         (ignore-errors (x-set-selection 'CLIPBOARD html)))
       (message "html export done, pushed to kill ring and clipboard"))))
 #+end_src

**** Adopting for Gnus

 The whole magic lies in the special strings that mark a HTML
 attachment.  So you might just have to find out what these special
 strings are in message-mode and modify the functions accordingly.
*** Add sunrise/sunset times to the agenda.
 #+index: Agenda!Diary s-expressions
   -- Nick Dokos

 The diary package provides the function =diary-sunrise-sunset= which can be used
 in a diary s-expression in some agenda file like this:

 #+begin_src org-mode
 %%(diary-sunrise-sunset)
 #+end_src

 Seb Vauban asked if it is possible to put sunrise and sunset in
 separate lines. Here is a hack to do that. It adds two functions (they
 have to be available before the agenda is shown, so I add them early
 in my org-config file which is sourced from .emacs, but you'll have to
 suit yourself here) that just parse the output of
 diary-sunrise-sunset, instead of doing the right thing which would be
 to take advantage of the data structures that diary/solar.el provides.
 In short, a hack - so perfectly suited for inclusion here :-)

 The functions (and latitude/longitude settings which you have to modify for
 your location) are as follows:

 #+begin_src emacs-lisp
 (setq calendar-latitude 48.2)
 (setq calendar-longitude 16.4)
 (setq calendar-location-name "Vienna, Austria")

 (autoload 'solar-sunrise-sunset "solar.el")
 (autoload 'solar-time-string "solar.el")
 (defun diary-sunrise ()
   "Local time of sunrise as a diary entry.
 The diary entry can contain `%s' which will be replaced with
 `calendar-location-name'."
   (let ((l (solar-sunrise-sunset date)))
     (when (car l)
       (concat
	(if (string= entry "")
            "Sunrise"
          (format entry (eval calendar-location-name))) " "
          (solar-time-string (caar l) nil)))))

 (defun diary-sunset ()
   "Local time of sunset as a diary entry.
 The diary entry can contain `%s' which will be replaced with
 `calendar-location-name'."
   (let ((l (solar-sunrise-sunset date)))
     (when (cadr l)
       (concat
	(if (string= entry "")
            "Sunset"
          (format entry (eval calendar-location-name))) " "
          (solar-time-string (caadr l) nil)))))
 #+end_src

 You also need to add a couple of diary s-expressions in one of your agenda
 files:

 #+begin_src org-mode
 %%(diary-sunrise)Sunrise in %s
 %%(diary-sunset)
 #+end_src

 This will show sunrise with the location and sunset without it.

 The thread on the mailing list that started this can be found [[http://thread.gmane.org/gmane.emacs.orgmode/38723Here%20is%20a%20pointer%20to%20the%20thread%20on%20the%20mailing%20list][here]].
 In comparison to the version posted on the mailing list, this one
 gets rid of the timezone information and can show the location.
*** Add lunar phases to the agenda.
 #+index: Agenda!Diary s-expressions
    -- Rüdiger

 Emacs comes with =lunar.el= to display the lunar phases (=M-x lunar-phases=).
 This can be used to display lunar phases in the agenda display with the
 following function:

 #+begin_src emacs-lisp
 (require 'cl-lib)

 (org-no-warnings (defvar date))
 (defun org-lunar-phases ()
   "Show lunar phase in Agenda buffer."
   (require 'lunar)
   (let* ((phase-list (lunar-phase-list (nth 0 date) (nth 2 date)))
          (phase (cl-find-if (lambda (phase) (equal (car phase) date))
                             phase-list)))
     (when phase
       (setq ret (concat (lunar-phase-name (nth 2 phase)) " "
                         (substring (nth 1 phase) 0 5))))))
 #+end_src

 Add the following line to an agenda file:

 #+begin_src org-mode
** Lunar phase
 #+CATEGORY: Lunar
 %%(org-lunar-phases)
 #+end_src

 This should display an entry on new moon, first/last quarter moon, and on full
 moon.  You can customize the entries by customizing =lunar-phase-names=.

 E.g., to add Unicode symbols:

 #+begin_src emacs-lisp
 (setq lunar-phase-names
       '("● New Moon" ; Unicode symbol: 🌑 Use full circle as fallback
         "☽ First Quarter Moon"
         "○ Full Moon" ; Unicode symbol: 🌕 Use empty circle as fallback
         "☾ Last Quarter Moon"))
 #+end_src

 Unicode 6 even provides symbols for the Moon with nice faces.  But those
 symbols are currently barely supported in fonts.
 See [[https://en.wikipedia.org/wiki/Astronomical_symbols#Moon][Astronomical symbols on Wikipedia]].

*** Export BBDB contacts to org-contacts.el
 #+index: Address Book!BBDB to org-contacts
 Try this tool by Wes Hardaker:

 http://www.hardakers.net/code/bbdb-to-org-contacts/

*** Calculating date differences - how to write a simple elisp function
 #+index: Timestamp!date calculations
 #+index: Elisp!technique

 Alexander Wingård asked how to calculate the number of days between a
 time stamp in his org file and today (see
 http://thread.gmane.org/gmane.emacs.orgmode/46881).  Although the
 resulting answer is probably not of general interest, the method might
 be useful to a budding Elisp programmer.

 Alexander started from an already existing org function,
 =org-evaluate-time-range=.  When this function is called in the context
 of a time range (two time stamps separated by "=--="), it calculates the
 number of days between the two dates and outputs the result in Emacs's
 echo area. What he wanted was a similar function that, when called from
 the context of a single time stamp, would calculate the number of days
 between the date in the time stamp and today. The result should go to
 the same place: Emacs's echo area.

 The solution presented in the mail thread is as follows:

 #+begin_src emacs-lisp
 (defun aw/org-evaluate-time-range (&optional to-buffer)
   (interactive)
   (if (org-at-date-range-p t)
       (org-evaluate-time-range to-buffer)
     ;; otherwise, make a time range in a temp buffer and run o-e-t-r there
     (let ((headline (buffer-substring (point-at-bol) (point-at-eol))))
       (with-temp-buffer
	 (insert headline)
	 (goto-char (point-at-bol))
	 (re-search-forward org-ts-regexp (point-at-eol) t)
	 (if (not (org-at-timestamp-p t))
	     (error "No timestamp here"))
	 (goto-char (match-beginning 0))
	 (org-insert-time-stamp (current-time) nil nil)
	 (insert "--")
	 (org-evaluate-time-range to-buffer)))))
 #+end_src

 The function assumes that point is on some line with some time stamp
 (or a date range) in it. Note that =org-evaluate-time-range= does not care
 whether the first date is earlier than the second: it will always output
 the number of days between the earlier date and the later date.

 As stated before, the function itself is of limited interest (although
 it satisfied Alexander's need).The *method* used might be of wider
 interest however, so here is a short explanation.

 The idea is that we want =org-evaluate-time-range= to do all the
 heavy lifting, but that function requires that it be in a date-range
 context. So the function first checks whether it's in a date range
 context already: if so, it calls =org-evaluate-time-range= directly
 to do the work. The trick now is to arrange things so we can call this
 same function in the case where we do *not* have a date range
 context. In that case, we manufacture one: we create a temporary
 buffer, copy the line with the purported time stamp to the temp
 buffer, find the time stamp (signal an error if no time stamp is
 found) and insert a new time stamp with the current time before the
 existing time stamp, followed by "=--=": voilà, we now have a time range
 on which we can apply our old friend =org-evaluate-time-range= to
 produce the answer. Because of the above-mentioned property
 of =org-evaluate-time-range=, it does not matter if the existing
 time stamp is earlier or later than the current time: the correct
 number of days is output.

 Note that at the end of the call to =with-temp-buffer=, the temporary
 buffer goes away.  It was just used as a scratch pad for the function
 to do some figuring.

 The idea of using a temp buffer as a scratch pad has wide
 applicability in Emacs programming. The rest of the work is knowing
 enough about facilities provided by Emacs (e.g. regexp searching) and
 by Org (e.g. checking for time stamps and generating a time stamp) so
 that you don't reinvent the wheel, and impedance-matching between the
 various pieces.

*** ibuffer and org files

 Neil Smithline posted this snippet to let you browse org files with
 =ibuffer=:

 #+BEGIN_SRC emacs-lisp
 (require 'ibuffer)

 (defun org-ibuffer ()
   "Open an `ibuffer' window showing only `org-mode' buffers."
   (interactive)
   (ibuffer nil "*Org Buffers*" '((used-mode . org-mode))))
 #+END_SRC

*** Enable org-mode links in other modes

 Sean O'Halpin wrote a minor mode for this, please check it [[https://github.com/seanohalpin/org-link-minor-mode][here]].

 See the relevant discussion [[http://thread.gmane.org/gmane.emacs.orgmode/58715/focus%3D58794][here]].

*** poporg.el: edit comments in org-mode

 [[https://github.com/pinard/PopOrg/blob/master/poporg.el][poporg.el]] is a library by François Pinard which lets you edit comments
 from your code using a separate org-mode buffer.

*** Convert a .csv file to an Org-mode table

 Nicolas Richard has a [[http://article.gmane.org/gmane.emacs.orgmode/65456][nice recipe]] using the pcsv library ([[http://marmalade-repo.org/packages/pcsv][available]] from
 the Marmelade ELPA repository):

 #+BEGIN_SRC emacs-lisp
 (defun yf/lisp-table-to-org-table (table &optional function)
   "Convert a lisp table to `org-mode' syntax, applying FUNCTION to each of its elements.
 The elements should not have any more newlines in them after
 applying FUNCTION ; the default converts them to spaces. Return
 value is a string containg the unaligned `org-mode' table."
   (unless (functionp function)
     (setq function (lambda (x) (replace-regexp-in-string "\n" " " x))))
   (mapconcat (lambda (x)                ; x is a line.
		(concat "| " (mapconcat function x " | ") " |"))
              table "\n"))

 (defun yf/csv-to-table (beg end)
 "Convert a csv file to an `org-mode' table."
   (interactive "r")
   (require 'pcsv)
   (insert (yf/lisp-table-to-org-table (pcsv-parse-region beg end)))
   (delete-region beg end)
   (org-table-align))
 #+END_SRC

** Hacking Org: Working with Org-mode and External Programs.
*** Use Org-mode with Screen [Andrew Hyatt]
 #+index: Link!to screen session
 "The general idea is that you start a task in which all the work will
 take place in a shell.  This usually is not a leaf-task for me, but
 usually the parent of a leaf task.  From a task in your org-file, M-x
 ash-org-screen will prompt for the name of a session.  Give it a name,
 and it will insert a link.  Open the link at any time to go the screen
 session containing your work!"

 http://article.gmane.org/gmane.emacs.orgmode/5276

 #+BEGIN_SRC emacs-lisp
 (require 'term)

 (defun ash-org-goto-screen (name)
   "Open the screen with the specified name in the window"
   (interactive "MScreen name: ")
   (let ((screen-buffer-name (ash-org-screen-buffer-name name)))
     (if (member screen-buffer-name
                 (mapcar 'buffer-name (buffer-list)))
         (switch-to-buffer screen-buffer-name)
       (switch-to-buffer (ash-org-screen-helper name "-dr")))))

 (defun ash-org-screen-buffer-name (name)
   "Returns the buffer name corresponding to the screen name given."
   (concat "*screen " name "*"))

 (defun ash-org-screen-helper (name arg)
   ;; Pick the name of the new buffer.
   (let ((term-ansi-buffer-name
	  (generate-new-buffer-name
	   (ash-org-screen-buffer-name name))))
     (setq term-ansi-buffer-name
           (term-ansi-make-term
	    term-ansi-buffer-name "/usr/bin/screen" nil arg name))
     (set-buffer term-ansi-buffer-name)
     (term-mode)
     (term-char-mode)
     (term-set-escape-char ?\C-x)
     term-ansi-buffer-name))

 (defun ash-org-screen (name)
   "Start a screen session with name"
   (interactive "MScreen name: ")
   (save-excursion
     (ash-org-screen-helper name "-S"))
   (insert-string (concat "[[screen:" name "]]")))

 ;; And don't forget to add ("screen" . "elisp:(ash-org-goto-screen
 ;; \"%s\")") to org-link-abbrev-alist.
 #+END_SRC

*** Org Agenda + Appt + Zenity
    :PROPERTIES:
    :CUSTOM_ID: org-agenda-appt-zenity
    :END:

 #+index: Appointment!reminders
 #+index: Appt!Zenity
 #+BEGIN_HTML
 <a name="agenda-appt-zenity"></a>
 #+END_HTML
 Russell Adams posted this setup [[http://article.gmane.org/gmane.emacs.orgmode/5806][on the list]].  It makes sure your agenda
 appointments are known by Emacs, and it displays warnings in a [[http://live.gnome.org/Zenity][zenity]]
 popup window.

 #+BEGIN_SRC emacs-lisp
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ; For org appointment reminders

 ;; Get appointments for today
 (defun my-org-agenda-to-appt ()
   (interactive)
   (setq appt-time-msg-list nil)
   (let ((org-deadline-warning-days 0))    ;; will be automatic in org 5.23
         (org-agenda-to-appt)))

 ;; Run once, activate and schedule refresh
 (my-org-agenda-to-appt)
 (appt-activate t)
 (run-at-time "24:01" nil 'my-org-agenda-to-appt)

 ; 5 minute warnings
 (setq appt-message-warning-time 15)
 (setq appt-display-interval 5)

 ; Update appt each time agenda opened.
 (add-hook 'org-finalize-agenda-hook 'my-org-agenda-to-appt)

 ; Setup zenify, we tell appt to use window, and replace default function
 (setq appt-display-format 'window)
 (setq appt-disp-window-function (function my-appt-disp-window))

 (defun my-appt-disp-window (min-to-app new-time msg)
   (save-window-excursion (shell-command (concat
     "/usr/bin/zenity --info --title='Appointment' --text='"
     msg "' &") nil nil)))
 #+END_SRC

*** Org and appointment notifications on Mac OS 10.8

 Sarah Bagby [[http://mid.gmane.org/EA76104A-9ACD-4141-8D33-2E4D810D9B5A%2540geol.ucsb.edu][posted some code]] on how to get appointments notifications on
 Mac OS 10.8 with [[https://github.com/alloy/terminal-notifier][terminal-notifier]].

*** Org-Mode + gnome-osd
 #+index: Appointment!reminders
 #+index: Appt!gnome-osd
 Richard Riley uses gnome-osd in interaction with Org-Mode to display
 appointments.  You can look at the code on the [[http://www.emacswiki.org/emacs-en/OrgMode-OSD][emacswiki]].

*** txt2org convert text data to org-mode tables
 From Eric Schulte

 I often find it useful to generate Org-mode tables on the command line
 from tab-separated data.  The following awk script makes this easy to
 do.  Text data is read from STDIN on a pipe and any command line
 arguments are interpreted as rows at which to insert hlines.

 Here are two usage examples.
 1. running the following
    : $ cat <<EOF|~/src/config/bin/txt2org
    : one 1
    : two 2
    : three 3
    : twenty 20
    : EOF                  
    results in
    : |    one |  1 |
    : |    two |  2 |
    : |  three |  3 |
    : | twenty | 20 |

 2. and the following (notice the command line argument)
    : $ cat <<EOF|~/src/config/bin/txt2org 1
    : strings numbers                                          
    : one 1
    : two 2
    : three 3
    : twenty 20
    : EOF 
    results in
    : | strings | numbers |
    : |---------+---------|
    : |     one |       1 |
    : |     two |       2 |
    : |   three |       3 |
    : |  twenty |      20 |

 Here is the script itself
 #+begin_src awk
   #!/usr/bin/gawk -f
   #
   # Read tab separated data from STDIN and output an Org-mode table.
   #
   # Optional command line arguments specify row numbers at which to
   # insert hlines.
   #
   BEGIN {
       for(i=1; i<ARGC; i++){
           hlines[ARGV[i]+1]=1; ARGV[i] = "-"; } }
  
   {
       if(NF > max_nf){ max_nf = NF; };
       for(f=1; f<=NF; f++){
           if(length($f) > lengths[f]){ lengths[f] = length($f); };
           row[NR][f]=$f; } }
  
   END {
       hline_str="|"
       for(f=1; f<=max_nf; f++){
           for(i=0; i<(lengths[f] + 2); i++){ hline_str=hline_str "-"; }
           if( f != max_nf){ hline_str=hline_str "+"; }
           else            { hline_str=hline_str "|"; } }
  
       for(r=1; r<=NR; r++){ # rows
           if(hlines[r] == 1){ print hline_str; }
           printf "|";
           for(f=1; f<=max_nf; f++){ # columns
               cell=row[r][f]; padding=""
               for(i=0; i<(lengths[f] - length(cell)); i++){ padding=padding " "; }
               # for now just print everything right-aligned
               # if(cell ~ /[0-9.]/){ printf " %s%s |", cell, padding; }
               # else{                printf " %s%s |", padding, cell; }
               printf " %s%s |", padding, cell; }
           printf "\n"; }
      
       if(hlines[NR+1]){ print hline_str; } }
 #+end_src

*** remind2org
 #+index: Agenda!Views
 #+index: Agenda!and Remind (external program)
 From Detlef Steuer

 http://article.gmane.org/gmane.emacs.orgmode/5073

 #+BEGIN_QUOTE
 Remind (http://www.roaringpenguin.com/products/remind) is a very powerful
 command line calendaring program. Its features supersede the possibilities
 of orgmode in the area of date specifying, so that I want to use it
 combined with orgmode.

 Using the script below I'm able use remind and incorporate its output in my
 agenda views.  The default of using 13 months look ahead is easily
 changed. It just happens I sometimes like to look a year into the
 future. :-)
 #+END_QUOTE

*** Useful webjumps for conkeror
 #+index: Shortcuts!conkeror
 If you are using the [[http://conkeror.org][conkeror browser]], maybe you want to put this into
 your =~/.conkerorrc= file:

 #+begin_example
 define_webjump("orglist", "http://search.gmane.org/?query=%s&group=gmane.emacs.orgmode");
 define_webjump("worg", "http://www.google.com/cse?cx=002987994228320350715%3Az4glpcrritm&ie=UTF-8&q=%s&sa=Search&siteurl=orgmode.org%2Fworg%2F");
 #+end_example

 It creates two [[http://conkeror.org/Webjumps][webjumps]] for easily searching the Worg website and the
 Org-mode mailing list.

*** Use MathJax for HTML export without requiring JavaScript
 #+index: Export!MathJax
 As of 2010-08-14, MathJax is the default method used to export math to HTML.

 If you like the results but do not want JavaScript in the exported pages,
 check out [[http://www.jboecker.de/2010/08/15/staticmathjax.html][Static MathJax]], a XULRunner application which generates a static
 HTML file from the exported version. It can also embed all referenced fonts
 within the HTML file itself, so there are no dependencies to external files.

 The download archive contains an elisp file which integrates it into the Org
 export process (configurable per file with a "#+StaticMathJax:" line).

 Read README.org and the comments in org-static-mathjax.el for usage instructions.
*** Search Org files using lgrep
 #+index: search!lgrep
 Matt Lundin suggests this:

 #+begin_src emacs-lisp
   (defun my-org-grep (search &optional context)
     "Search for word in org files.

 Prefix argument determines number of lines."
     (interactive "sSearch for: \nP")
     (let ((grep-find-ignored-files '("#*" ".#*"))
	   (grep-template (concat "grep <X> -i -nH "
				  (when context
				    (concat "-C" (number-to-string context)))
				  " -e <R> <F>")))
       (lgrep search "*org*" "/home/matt/org/")))

   (global-set-key (kbd "<f8>") 'my-org-grep)
 #+end_src

*** Automatic screenshot insertion
 #+index: Link!screenshot
 Suggested by Russell Adams

 #+begin_src emacs-lisp
   (defun my-org-screenshot ()
     "Take a screenshot into a time stamped unique-named file in the
   same directory as the org-buffer and insert a link to this file."
     (interactive)
     (setq filename
           (concat
            (make-temp-name
             (concat (buffer-file-name)
                     "_"
                     (format-time-string "%Y%m%d_%H%M%S_")) ) ".png"))
     (call-process "import" nil nil nil filename)
     (insert (concat "[[" filename "]]"))
     (org-display-inline-images))
 #+end_src

*** Capture invitations/appointments from MS Exchange emails
 #+index: Appointment!MS Exchange
 Dirk-Jan C.Binnema [[http://article.gmane.org/gmane.emacs.orgmode/27684/][provided]] code to do this.  Please check
 [[file:code/elisp/org-exchange-capture.el][org-exchange-capture.el]]

*** Audio/video file playback within org mode
 #+index: Link!audio/video
 Paul Sexton provided code that makes =file:= links to audio or video files
 (MP3, WAV, OGG, AVI, MPG, et cetera) play those files using the [[https://github.com/dbrock/bongo][Bongo]] Emacs
 media player library. The user can pause, skip forward and backward in the
 track, and so on from without leaving Emacs. Links can also contain a time
 after a double colon -- when this is present, playback will begin at that
 position in the track.

 See the file [[file:code/elisp/org-player.el][org-player.el]]

*** Under X11 Keep a window with the current agenda items at all time
 #+index: Agenda!dedicated window
 I struggle to keep (in emacs) a window with the agenda at all times.
 For a long time I have wanted a sticky window that keeps this
 information, and then use my window manager to place it and remove its
 decorations (I can also force its placement in the stack: top always,
 for example).

 I wrote a small program in qt that simply monitors an HTML file and
 displays it. Nothing more. It does the work for me, and maybe somebody
 else will find it useful. It relies on exporting the agenda as HTML
 every time the org file is saved, and then this little program
 displays the html file. The window manager is responsible of removing
 decorations, making it sticky, and placing it in same place always.

 Here is a screenshot (see window to the bottom right). The decorations
 are removed by the window manager:

 http://turingmachine.org/hacking/org-mode/orgdisplay.png

 Here is the code. As I said, very, very simple, but maybe somebody will
 find if useful.

 http://turingmachine.org/hacking/org-mode/

 --daniel german

*** Script (thru procmail) to output emails to an Org file
 #+index: Conversion!email to org file
 Tycho Garen sent [[http://comments.gmane.org/gmane.emacs.orgmode/44773][this]]:

 : I've [...] created some procmail and shell glue that takes emails and
 : inserts them into an org-file so that I can capture stuff on the go using
 : the email program.

 Everything is documented [[http://tychoish.com/code/org-mail/][here]].

*** Save File With Different Format for Headings (fileconversion)
    :PROPERTIES:
    :CUSTOM_ID: fileconversion
    :END:
 #+index: Conversion!fileconversion

 Using hooks and on the fly
 - when writing a buffer to the file replace the leading stars from headings
   with a file char
 - when reading a file into the buffer replace the file chars with leading
   stars for headings

 To change to save an Org file in one of the formats or back just add or
 remove the keyword in the STARTUP line and save.

 Now you can also change to Fundamental mode to see how the file looks like
 on the level of the file, go back to Org mode, reenter Org mode or change to
 any other major mode and the conversion gets done whenever necessary.

**** Headings Without Leading Stars (hidestarsfile and nbspstarsfile)
     :PROPERTIES:
     :CUSTOM_ID: hidestarsfile
     :END:
 #+index: Conversion!fileconversion hidestarsfile

 This is like "a cleaner outline view":
 http://orgmode.org/manual/Clean-view.html

 Example of the _file content_ first with leading stars as usual and below
 without leading stars through "#+STARTUP: odd hidestars hidestarsfile":

 #+BEGIN_EXAMPLE
   #+STARTUP: odd hidestars
   [...]
   ***** TODO section
   ******* subsection
   ********* subsubsec
             - bla bla
   ***** section
         - bla bla
   ******* subsection
 #+END_EXAMPLE

 #+BEGIN_EXAMPLE
   #+STARTUP: odd hidestars hidestarsfile
   [...]
       * TODO section
         * subsection
           * subsubsec
             - bla bla
       * section
         - bla bla
         * subsection
 #+END_EXAMPLE

 The latter is convenient for better human readability when an Org file,
 additionally to Emacs, is read with a file viewer or, for smaller edits,
 with an editor not capable of the Org file format.

 hidestarsfile is a hack and can not become part of the Org core:
 - An Org file with hidestarsfile can not contain list items with a star as
   bullet due to the syntax conflict at read time. Mark E. Shoulson suggested
   to use the non-breaking space which is now implemented in fileconversion
   as nbspstarsfile as an alternative for hidestarsfile. Although I don't
   recommend it because an editor like typically e. g. Emacs may render the
   non-breaking space differently from the space 0x20.
 - An Org file with hidestarsfile can almost not be edited with an Org mode
   without added functionality of hidestarsfile as long as the file is not
   converted back.

**** Headings in Markdown Format (markdownstarsfile)
     :PROPERTIES:
     :CUSTOM_ID: markdownstarsfile
     :END:
 #+index: Conversion!fileconversion markdownstarsfile

 For "oddeven" you can use markdownstarsfile to be readable or even basically
 editable with Markdown (does not make much sense with "odd", see
 org-convert-to-odd-levels and org-convert-to-oddeven-levels for how to
 convert).

 Example of the _file content_:

 #+BEGIN_EXAMPLE
   #+STARTUP: oddeven markdownstarsfile
   # section level 1
     1. first item of numbered list (same format in Org and Markdown)
   ## section level 2
      - first item of unordered list (same format in Org and Markdown)
   ### section level 3
       + first item of unordered list (same format in Org and Markdown)
   #### section level 4
	* first item of unordered list (same format in Org and Markdown)
	* avoid this item type to be compatible with Org hidestarsfile
 #+END_EXAMPLE

 An Org file with markdownstarsfile can not contain code comment lines
 prefixed with "#", even not when within source blocks.

**** emacs-lisp code
     :PROPERTIES:
     :CUSTOM_ID: fileconversion-code
     :END:
 #+index: Conversion!fileconversion emacs-lisp code

 #+BEGIN_SRC emacs-lisp
   ;; - fileconversion version 0.7
   ;; - DISCLAIMER: Make a backup of your Org files before using
   ;;   my-org-fileconv-*.
   ;; - supported formats: hidestarsfile, markdownstarsfile

   ;; design summary: fileconversion is a round robin of two states
   ;; linked by two actions:
   ;; - state v-org-fileconv-level-org-p is nil: the level is “file”
   ;;   (encoded)
   ;; - action f-org-fileconv-decode: replace file char with “*”
   ;; - state v-org-fileconv-level-org-p is t: the level is “Org”
   ;;   (decoded)
   ;; - action f-org-fileconv-encode: replace “*” with file char
   ;; naming convention of prefix:
   ;; - f-[...]: “my function”, instead of the unspecific prefix “my-”
   ;; - v-[...]: “my variable”, instead of the unspecific prefix “my-”

   (defvar v-org-fileconv-level-org-p nil
     "Whether level of buffer is Org or only file.
   nil means the level is file (encoded), non-nil means the level is Org
   (decoded).")
   (make-variable-buffer-local 'v-org-fileconv-level-org-p)
   ;; survive a change of major mode that does kill-all-local-variables,
   ;; e. g. when reentering Org mode through “C-c C-c” on a STARTUP line
   (put 'v-org-fileconv-level-org-p 'permanent-local t)

   (add-hook 'org-mode-hook 'f-org-fileconv-init
             ;; _append_ to hook to have a higher chance that a message
             ;; from this function will be visible as the last message in
             ;; the minibuffer
             t
             ;; hook addition globally
             nil)

   (defun f-org-fileconv-init ()
     (interactive)
     ;; instrument only when converting really from/to an Org _file_, not
     ;; e. g. for a temp Org buffer unrelated to a file like used e. g.
     ;; when calling the old Org exporter
     (when (buffer-file-name)
       (message "INF: f-org-fileconv-init, buffer: %s" (buffer-name))
       (f-org-fileconv-decode)
       ;; the hooks are not permanent-local, this way and as needed they
       ;; will disappear when the major mode of the buffer changes
       (add-hook 'change-major-mode-hook 'f-org-fileconv-encode nil
                 ;; hook addition limited to buffer locally
                 t)
       (add-hook 'before-save-hook 'f-org-fileconv-encode nil
                 ;; hook addition limited to buffer locally
                 t)
       (add-hook 'after-save-hook 'f-org-fileconv-decode nil
                 ;; hook addition limited to buffer locally
                 t)))

   (defun f-org-fileconv-re ()
     "Check whether there is a STARTUP line for fileconversion.
   If found then return the expressions required for the conversion."
     (save-excursion
       (goto-char (point-min))  ;; beginning-of-buffer not allowed
       (let (re-list (count 0))
         (while (re-search-forward "^#\\+STARTUP:" nil t)
           ;; #+STARTUP: hidestarsfile
           (when (string-match-p "\\bhidestarsfile\\b"
                                 (thing-at-point 'line))
             ;; exclude e. g.:
             ;; - line starting with star for bold emphasis
             ;; - line of stars to underline section title in loosely
             ;;   quoted ASCII style (star at end of line)
             (setq re-list '("\\(\\* \\)"  ; common-re
                             ?\ ))         ; file-char
             (setq count (1+ count)))
           ;; #+STARTUP: nbspstarsfile
           (when (string-match-p "\\bnbspstarsfile\\b"
                                 (thing-at-point 'line))
             (setq re-list '("\\(\\* \\)"  ; common-re
                             ?\xa0))       ; file-char non-breaking space
             (setq count (1+ count)))
           ;; #+STARTUP: markdownstarsfile
           (when (string-match-p "\\bmarkdownstarsfile\\b"
                                 (thing-at-point 'line))
             ;; exclude e. g.:
             ;; - #STARTUP:
             (setq re-list '("\\( \\)"  ; common-re
                             ?#))       ; file-char
             (setq count (1+ count))))
         (when (> count 1)
           (error "More than one fileconversion found"))
         re-list)))

   (defun f-org-fileconv-decode ()
     "In headings replace file char with '*'."
     (let ((re-list (f-org-fileconv-re)))
       (when (and re-list (not v-org-fileconv-level-org-p))
         ;; no `save-excursion' to be able to keep point in case of error
         (let* ((common-re (nth 0 re-list))
		(file-char (nth 1 re-list))
		(file-re   (concat "^" (string file-char) "+" common-re))
		(org-re    (concat "^\\*+" common-re))
		len
		(p         (point)))
           (goto-char (point-min))  ;; beginning-of-buffer not allowed
           ;; syntax check
           (when (re-search-forward org-re nil t)
             (goto-char (match-beginning 0))
             (org-reveal)
             (error "Org fileconversion dec: syntax conflict at point"))
           (goto-char (point-min))  ;; beginning-of-buffer not allowed
           ;; substitution
           (with-silent-modifications
             (while (re-search-forward file-re nil t)
               (goto-char (match-beginning 0))
               ;; faster than a lisp call of insert and delete on each
               ;; single char
               (setq len (- (match-beginning 1) (match-beginning 0)))
               (insert-char ?* len)
               (delete-char len)))
           (goto-char p))))

           ;; notes for ediff when only one file has fileconversion:
           ;; - The changes to the buffer with fileconversion until here
           ;;   are not regarded by ediff-files because the first call to
           ;;   diff is made with the bare files directly. Only
           ;;   ediff-update-diffs and ediff-buffers write the decoded
           ;;   buffers to temp files and then call diff with them.
           ;; - Workarounds (choose one):
           ;;   - after ediff-files first do a "!" (ediff-update-diffs)
           ;;     in the "*Ediff Control Panel*"
           ;;   - instead of using ediff-files first open the files and
           ;;     then run ediff-buffers (better for e. g. a script that
           ;;     takes two files as arguments and uses "emacs --eval")

     ;; the level is Org most of all when no fileconversion is in effect
     (setq v-org-fileconv-level-org-p t))

   (defun f-org-fileconv-encode ()
     "In headings replace '*' with file char."
     (let ((re-list (f-org-fileconv-re)))
       (when (and re-list v-org-fileconv-level-org-p)
         ;; no `save-excursion' to be able to keep point in case of error
         (let* ((common-re (nth 0 re-list))
		(file-char (nth 1 re-list))
		(file-re   (concat "^" (string file-char) "+" common-re))
		(org-re    (concat "^\\*+" common-re))
		len
		(p         (point)))
           (goto-char (point-min))  ;; beginning-of-buffer not allowed
           ;; syntax check
           (when (re-search-forward file-re nil t)
             (goto-char (match-beginning 0))
             (org-reveal)
             (error "Org fileconversion enc: syntax conflict at point"))
           (goto-char (point-min))  ;; beginning-of-buffer not allowed
           ;; substitution
           (with-silent-modifications
             (while (re-search-forward org-re nil t)
               (goto-char (match-beginning 0))
               ;; faster than a lisp call of insert and delete on each
               ;; single char
               (setq len (- (match-beginning 1) (match-beginning 0)))
               (insert-char file-char len)
               (delete-char len)))
           (goto-char p)
           (setq v-org-fileconv-level-org-p nil))))
     nil)  ;; for the hook
 #+END_SRC

 Michael Brand

*** Meaningful diff for org files in a git repository
 #+index: git!diff org files
 Since most diff utilities are primarily meant for source code, it is
 difficult to read diffs of text files like ~.org~ files easily. If you
 version your org directory with a SCM like git you will know what I
 mean. However for git, there is a way around. You can use
 =gitattributes= to define a custom diff driver for org files. Then a
 regular expression can be used to configure how the diff driver
 recognises a "function".

 Put the following in your =<org_dir>/.gitattributes=.
 : *.org	diff=org
 Then put the following lines in =<org_dir>/.git/config=
 : [diff "org"]
 : 	xfuncname = "^(\\*+ [a-zA-Z0-9]+.+)$"

 This will let you see diffs for org files with each hunk identified by
 the unmodified headline closest to the changes. After the
 configuration a diff should look something like the example below.

 #+begin_example
 diff --git a/org-hacks.org b/org-hacks.org
 index a0672ea..92a08f7 100644
 --- a/org-hacks.org
 +++ b/org-hacks.org
 @@ -2495,6 +2495,22 @@ ** Script (thru procmail) to output emails to an Org file
 
  Everything is documented [[http://tychoish.com/code/org-mail/][here]].
 
 +** Meaningful diff for org files in a git repository
 +
 +Since most diff utilities are primarily meant for source code, it is
 +difficult to read diffs of text files like ~.org~ files easily. If you
 +version your org directory with a SCM like git you will know what I
 +mean. However for git, there is a way around. You can use
 +=gitattributes= to define a custom diff driver for org files. Then a
 +regular expression can be used to configure how the diff driver
 +recognises a "function".
 +
 +Put the following in your =<org_dir>/.gitattributes=.
 +: *.org	diff=org
 +Then put the following lines in =<org_dir>/.git/config=
 +: [diff "org"]
 +: 	xfuncname = "^(\\*+ [a-zA-Z0-9]+.+)$"
 +
  * Musings
 
  ** Cooking?  Brewing?
 #+end_example

*** Opening devonthink links

 John Wiegley wrote [[https://github.com/jwiegley/dot-emacs/blob/master/lisp/org-devonthink.el][org-devonthink.el]], which lets you handle devonthink
 links from org-mode.

** Musings

*** Cooking?  Brewing?
 #+index: beer!brewing
 #+index: cooking!conversions
 See [[http://article.gmane.org/gmane.emacs.orgmode/44981][this message]] from Erik Hetzner:

 It currently does metric/english conversion, and a few other tricks.
 Basically I just use calc’s units code.  I think scaling recipes, or
 turning percentages into weights would be pretty easy.

   https://gitorious.org/org-cook/org-cook

 There is also, for those interested:

   https://gitorious.org/org-brew/org-brew

 for brewing beer. This is again, mostly just calc functions, including
 hydrometer correction, abv calculation, priming sugar for a given CO_2
 volume, etc. More integration with org-mode should be possible: for
 instance it would be nice to be able to use a lookup table (of ingredients)
 to calculate target original gravity, IBUs, etc.
